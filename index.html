<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Radius 5 ‚Äî MiniApp</title>

<link rel="preconnect" href="https://unpkg.com">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Supabase (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.1/dist/umd/supabase.min.js"></script>

<!-- –¢–í–û–ò –ö–õ–Æ–ß–ò –ë–£–î–£–¢ –ó–î–ï–°–¨ -->
<script src="config.js"></script>

<style>
  /* Reset tap highlights */
  * {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  
  :root{
    --bg:#0b0f16; --panel:#0d1422; --txt:#e9efff; --muted:#9fb0d9;
    --grad1:#7c3aed; --grad2:#22d3ee;
    --map-tiles:url('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png');
  }
  
  [data-theme="light"] {
    --bg:#f8fafc; --panel:#ffffff; --txt:#1e293b; --muted:#64748b;
    --grad1:#7c3aed; --grad2:#22d3ee;
    --map-tiles:url('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png');
  }

  html,body,#app{
    height:100%;margin:0;background:var(--bg);color:var(--txt);
    font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    transition:all 0.3s ease;
    overflow: hidden;
  }
  
  /* Make sure map is visible and occupies full container */
  #map{
    height:100%;position:relative;
    z-index: 0; /* below UI elements */
  }
  
  #ui{position:absolute;inset:0;pointer-events:none;z-index:900}
  
  .topbar{
    position:absolute;left:12px;right:12px;top:8px;display:flex;gap:10px;align-items:center;pointer-events:auto;flex-wrap:wrap;
    background:linear-gradient(180deg,rgba(13,22,38,.80),rgba(10,18,32,.78));
    border:1px solid rgba(140,160,255,.12);
    border-radius:18px;padding:10px 12px;backdrop-filter:blur(6px);
    /* Prevent background bleed artifacts behind rounded corners on some devices */
    overflow: hidden;
    /* ensure topbar doesn't cover map tiles (map canvas below) */
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
  }
  
  [data-theme="light"] .topbar{
    background:linear-gradient(180deg,rgba(255,255,255,.95),rgba(248,250,252,.93));
    border:1px solid rgba(99,102,241,.15);
    box-shadow:0 4px 12px rgba(0,0,0,.08);
    overflow: hidden;
  }
  
  .chips{
    display:flex;
    gap:8px;
    overflow:auto;
    scrollbar-width:none;
    flex:1 1 auto;
    padding:4px 2px;
    flex-wrap: nowrap;
    min-width: 0;
  }
  .chips::-webkit-scrollbar{display:none}
  .chip{
    background:#0e1624;color:var(--muted);padding:8px 16px;border-radius:12px;
    font-weight:700;white-space:nowrap;cursor:pointer;transition:all 0.2s ease;
    border: none;
    outline: none;
    position:relative;
    flex-shrink: 0;
    min-width: max-content;
    /* Fix: ensure gradient/rounding doesn't show stray vertical artifacts by clipping */
    overflow:hidden;
    -webkit-background-clip: padding-box;
    background-clip: padding-box;
    /* Force no image repetition artifacts */
    background-repeat: no-repeat;
    background-size: 100% 100%;
    box-shadow: none;
  }
  .chip.active{background:#17243a;color:#fff}
  [data-theme="light"] .chip{background:#f1f5f9;color:#64748b;border:1px solid #e2e8f0}
  [data-theme="light"] .chip.active{
    /* Fix: use a single smooth gradient + clip and no extra borders to avoid side stripes */
    background: linear-gradient(90deg,var(--grad1),var(--grad2));
    background-size: 100% 100%;
    -webkit-background-clip: padding-box;
    background-clip: padding-box;
    color:#fff;border-color:transparent;
  }
  
  .cta{
    position:absolute;left:96px;right:96px;bottom:24px;height:56px;border-radius:16px;z-index:960;
    background:linear-gradient(90deg,var(--grad1),var(--grad2));display:flex;align-items:center;justify-content:center;
    color:white;font-weight:900;letter-spacing:.4px;pointer-events:auto;cursor:pointer;transition:all 0.2s ease;
    box-shadow:0 4px 16px rgba(124,58,237,.3);
    border: none;
    outline: none;
  }
  .cta:hover{transform:translateY(-1px);box-shadow:0 6px 20px rgba(124,58,237,.4)}
  
  .profile-btn{
    position:absolute;left:20px;bottom:24px;width:56px;height:56px;border-radius:16px;z-index:961; pointer-events:auto;
    background:linear-gradient(135deg, var(--grad2), var(--grad1)); display:grid;place-items:center;cursor:pointer;transition:all 0.2s ease;
    box-shadow:0 4px 16px rgba(34,211,238,.3);
    border: none;
    outline: none;
  }
  .profile-btn:hover{transform:translateY(-1px);box-shadow:0 6px 20px rgba(34,211,238,.4)}
  .profile-btn svg{ width:24px;height:24px; stroke:#fff; stroke-width:1.8; fill:none }
  
  .settings-btn{
    position:absolute;right:20px;bottom:24px;width:56px;height:56px;border-radius:16px;z-index:961; pointer-events:auto;
    background:linear-gradient(135deg, var(--grad2), var(--grad1)); display:grid;place-items:center;cursor:pointer;transition:all 0.2s ease;
    box-shadow:0 4px 16px rgba(34,211,238,.3);
    border: none;
    outline: none;
  }
  .settings-btn:hover{transform:translateY(-1px);box-shadow:0 6px 20px rgba(34,211,238,.4)}
  .settings-btn svg{ width:24px;height:24px; stroke:#fff; stroke-width:1.8; fill:none }
  
  /* –ö–Ω–æ–ø–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç —Ç–æ–ø–±–∞—Ä–∞ */
  .geolocation-btn{
    position:absolute;
    right:20px;
    top:76px;
    width:56px;
    height:56px;
    border-radius:50%;
    background:linear-gradient(135deg, var(--grad2), var(--grad1));
    display:grid;
    place-items:center;
    cursor:pointer;
    transition:all 0.2s ease;
    box-shadow:0 4px 16px rgba(34,211,238,.3);
    pointer-events:auto;
    z-index:910;
    border: none;
    outline: none;
  }
  .geolocation-btn:hover{transform:translateY(-1px);box-shadow:0 6px 20px rgba(34,211,238,.4)}
  .geolocation-btn svg{
    width:24px;
    height:24px;
    stroke:#fff;
    stroke-width:1.8;
    fill:none;
  }
  
  /* –ö–Ω–æ–ø–∫–∞ Delete - –≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º–∞ –¥–ª—è —Å–æ–∑–¥–∞—Ç–µ–ª—è –ø—É–ª—å—Å–∞ */
  .delete-btn-pulse{
    position:absolute;right:88px;bottom:24px;width:56px;height:56px;border-radius:16px;z-index:961; pointer-events:auto;
    background:linear-gradient(135deg, #ef4444, #dc2626); display:grid;place-items:center;cursor:pointer;transition:all 0.2s ease;
    box-shadow:0 4px 16px rgba(239,68,68,.3);
    border: none;
    outline: none;
  }
  .delete-btn-pulse:hover{transform:translateY(-1px);box-shadow:0 6px 20px rgba(239,68,68,.4)}
  .delete-btn-pulse svg{ width:24px;height:24px; stroke:#fff; stroke-width:2; fill:none }
  
  .leaflet-control-zoom,.leaflet-control-attribution{display:none!important}

  /* –º–∞—Ä–∫–µ—Ä—ã —Å —Ü–≤–µ—Ç–∞–º–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ */
  .pulse{width:52px;height:52px;border-radius:50%;position:relative;display:grid;place-items:center}
  .pulse::after{content:"";position:absolute;inset:-2px;border-radius:50%;box-shadow:0 0 16px currentColor,inset 0 0 8px rgba(255,255,255,.2)}
  [data-theme="light"] .pulse::after{box-shadow:0 0 16px currentColor,inset 0 0 8px rgba(255,255,255,.4)}
  
  /* –¶–≤–µ—Ç–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏: –∑–µ–ª–µ–Ω—ã–π (0-30–º–∏–Ω), –æ—Ä–∞–Ω–∂–µ–≤—ã–π (30-60–º–∏–Ω), –∫—Ä–∞—Å–Ω—ã–π (60-120–º–∏–Ω) */
  .pulse-green{ --c:#10b981; color: #10b981; }
  .pulse-orange{ --c:#f97316; color: #f97316; }
  .pulse-red{ --c:#ef4444; color: #ef4444; }
  
  /* –ê–Ω–∏–º–∞—Ü–∏–∏ —Å —Ä–∞–∑–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é */
  .ring{position:absolute;inset:-10px;border-radius:50%;border:2px solid var(--c);opacity:.45}
  .ring-fast{animation:ring 2s ease-out infinite}
  .ring-medium{animation:ring 3s ease-out infinite}
  .ring-slow{animation:ring 4s ease-out infinite}
  
  .pulse>span{font-size:26px;filter:drop-shadow(0 2px 2px rgba(0,0,0,.45))}
  @keyframes ring{0%{transform:scale(.7);opacity:.6}50%{transform:scale(1.6);opacity:.3}100%{transform:scale(1.85);opacity:0}}
  
.leaflet-tooltip.pulse-label{
  background:rgba(10,14,22,.92);
  color:#e6ecff;
  padding:16px 20px;
  border-radius:16px;
  border:1px solid rgba(120,160,255,.26);
  min-width:220px;
  max-width:420px;
  backdrop-filter:blur(8px);
  white-space:normal;
  word-break:break-word;
  overflow-wrap:anywhere;
  line-height:1.45;
  box-sizing:border-box;
  display:flex;
  justify-content:center;
  pointer-events:auto;
}
[data-theme="light"] .leaflet-tooltip.pulse-label{
  background:rgba(255,255,255,.95);
  color:#1e293b;
  border:1px solid rgba(99,102,241,.2);
  box-shadow:0 10px 32px rgba(0,0,0,.12);
}
.leaflet-tooltip.pulse-label .pulse-label-content{
  display:flex;
  flex-direction:column;
  gap:8px;
  align-items:center;
  text-align:center;
}
.leaflet-tooltip.pulse-label .pulse-message{
  font-weight:600;
  margin:0;
  width:100%;
}
.leaflet-tooltip.pulse-label .pulse-category{
  font-size:12px;
  padding:4px 12px;
  border-radius:999px;
  background:rgba(120,160,255,.16);
  color:#bfc8e8;
  letter-spacing:.02em;
  text-transform:uppercase;
}
[data-theme="light"] .leaflet-tooltip.pulse-label .pulse-category{
  background:rgba(99,102,241,.12);
  color:#4338ca;
}
.leaflet-tooltip.pulse-label .pulse-tag{
  font-size:11px;
  color:var(--grad2);
  text-transform:uppercase;
  letter-spacing:.06em;
}
  
  .meDot{width:18px;height:18px;border-radius:50%;background:#10b981;border:3px solid rgba(16,185,129,.9);
    box-shadow:0 0 12px rgba(16,185,129,.5),0 0 0 8px rgba(16,185,129,.08);animation:me 1.6s ease-out infinite}
  @keyframes me{0%{transform:scale(.94)}50%{transform:scale(1.04)}100%{transform:scale(.94)}}

  /* –º–æ–¥–∞–ª–∫–∏ */
  .modal{
    position:fixed;inset:0;display:none;align-items:flex-end;justify-content:center;
    background:rgba(9,12,20,.45);z-index:1200;transition:background .25s ease;
  }
  .modal.open{display:flex}
  .sheet{
    width:100%;background:#0f1729;border:1px solid rgba(140,160,255,.14);
    border-radius:20px 20px 0 0;padding:20px 20px 24px;max-height:90vh;overflow-y:auto;
  }
  [data-theme="light"] .sheet{
    background:#ffffff;border:1px solid rgba(99,102,241,.15);
    box-shadow:0 -4px 20px rgba(0,0,0,.1);
  }
  #createSheet{
    transform:translateY(100%);
    transition:transform .32s cubic-bezier(.22,1,.36,1);
    will-change:transform;
  }
  #createModal.closing #createSheet{
    transition:transform .28s ease;
  }
  #settingsSheet{
    display:flex;
    flex-direction:column;
    gap:20px;
    overflow:hidden;
    transform:translateY(100%);
    transition:transform .32s cubic-bezier(.22,1,.36,1);
    will-change:transform;
    touch-action:pan-y;
  }
  #settingsSheet.dragging{
    transition:none;
  }
  #settingsModal.closing #settingsSheet{
    transition:transform .28s ease;
  }
  #settingsSheet.spring{
    transition:transform .5s cubic-bezier(.25,1.5,.5,1);
  }
  .sheet-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:16px;
    position:sticky;
    top:0;
    padding-bottom:8px;
    background:linear-gradient(180deg,rgba(15,23,41,.98),rgba(15,23,41,.8));
    z-index:1;
    cursor:grab;
    user-select:none;
    touch-action:none;
  }
  .sheet-header:active{cursor:grabbing}
  [data-theme="light"] .sheet-header{
    background:linear-gradient(180deg,rgba(255,255,255,.98),rgba(255,255,255,.85));
  }
  .sheet-header h3{
    margin:0;
    font-size:20px;
    font-weight:700;
  }
  .sheet-close{
    width:36px;
    height:36px;
    border-radius:50%;
    border:none;
    outline:none;
    display:grid;
    place-items:center;
    font-size:18px;
    font-weight:600;
    color:#fff;
    background:linear-gradient(135deg,#38bdf8,#6366f1);
    cursor:pointer;
    transition:transform .2s ease;
  }
  .sheet-close:focus-visible{
    outline:2px solid rgba(255,255,255,.65);
    outline-offset:3px;
  }
  .sheet-close:hover{
    transform:translateY(-1px);
  }
  [data-theme="light"] .sheet-close{
    color:#fff;
    background:linear-gradient(135deg,#4f46e5,#22d3ee);
  }
  .sheet-body{
    flex:1;
    overflow-y:auto;
    display:flex;
    flex-direction:column;
    gap:16px;
    padding-right:4px;
    -webkit-overflow-scrolling:touch;
  }
  .sheet-body::-webkit-scrollbar{width:6px}
  .sheet-body::-webkit-scrollbar-thumb{background:rgba(148,163,184,.4);border-radius:999px}
  [data-theme="light"] .sheet-body::-webkit-scrollbar-thumb{background:rgba(99,102,241,.3)}
  .row{display:flex;gap:10px;margin:12px 0}
  .option-field{
    position:relative;
    width:100%;
    padding:14px 48px 14px 16px;
    border-radius:16px;
    background:linear-gradient(180deg,rgba(16,23,41,.96),rgba(12,18,30,.92));
    border:1px solid rgba(140,160,255,.14);
    box-shadow:0 8px 22px rgba(6,12,24,.45);
    cursor:pointer;
    transition:all 0.25s ease;
  }
  .option-field:hover{
    transform:translateY(-1px);
    box-shadow:0 14px 30px rgba(10,18,32,.55);
  }
  .option-field:active{
    transform:translateY(0);
  }
  .option-field .field-label{
    font-size:12px;
    font-weight:600;
    letter-spacing:.04em;
    color:rgba(159,176,217,.85);
    text-transform:uppercase;
    margin-bottom:6px;
  }
  .option-field .field-value{
    font-size:16px;
    font-weight:700;
    color:var(--txt);
  }
  .option-field::after{
    content:'';
    position:absolute;
    width:8px;
    height:8px;
    border-right:2px solid rgba(159,176,217,.82);
    border-bottom:2px solid rgba(159,176,217,.82);
    top:50%;
    right:20px;
    transform:translateY(-50%) rotate(-45deg);
    transition:border-color .2s ease,opacity .2s ease;
  }
  .option-field:hover::after{
    border-color:rgba(124,58,237,.85);
  }
  [data-theme="light"] .option-field{
    background:linear-gradient(180deg,rgba(255,255,255,.98),rgba(248,250,252,.95));
    border:1px solid rgba(99,102,241,.15);
    box-shadow:0 14px 28px rgba(15,23,42,.12);
  }
  [data-theme="light"] .option-field .field-label{
    color:#94a3b8;
  }
  [data-theme="light"] .option-field .field-value{
    color:#1e293b;
  }
  [data-theme="light"] .option-field::after{
    border-color:#94a3b8;
  }
  [data-theme="light"] .option-field:hover::after{
    border-color:rgba(124,58,237,.9);
  }
  .input,select,textarea{
    width:100%;background:#0e1624;border:1px solid rgba(255,255,255,.08);
    color:#e9efff;border-radius:12px;padding:12px;transition:all 0.2s ease;
    border: none;
    outline: none;
  }
  [data-theme="light"] .input,[data-theme="light"] select,[data-theme="light"] textarea{
    background:#f8fafc;border:1px solid #e2e8f0;color:#1e293b;
  }
  .input:focus,select:focus,textarea:focus{
    outline:none;border-color:var(--grad1);
  }
  
  .btn{
    padding:12px;border-radius:12px;text-align:center;background:#0e1624;
    border:1px solid rgba(255,255,255,.08);cursor:pointer;transition:all 0.2s ease;
    border: none;
    outline: none;
  }
  .btn.primary{
    background:linear-gradient(90deg,var(--grad1),var(--grad2));border:0;font-weight:800;
  }
  [data-theme="light"] .btn{
    background:#f1f5f9;border:1px solid #e2e8f0;color:#475569;
  }
  .footer{display:flex;gap:10px;margin-top:16px}
  .hint{color:#9fb0d9;font-size:12px;margin-top:4px}
  [data-theme="light"] .hint{color:#64748b}
  .modal.option-modal{z-index:1300}
  .option-modal .option-sheet{
    transform:translateY(100%);
    transition:transform .32s cubic-bezier(.22,1,.36,1);
    will-change:transform;
  }
  .option-modal.closing .option-sheet{
    transition:transform .28s ease;
  }
  .option-sheet{padding-bottom:24px}
  .option-header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  .option-header h3{margin:0}
  .modal-close{
    width:34px;
    height:34px;
    border-radius:12px;
    background:#141e33;
    display:grid;
    place-items:center;
    font-weight:700;
    color:var(--txt);
    cursor:pointer;
    border:1px solid rgba(255,255,255,.08);
    transition:all .2s ease;
  }
  .modal-close:hover{
    transform:translateY(-1px);
    box-shadow:0 10px 22px rgba(15,22,38,.55);
  }
  [data-theme="light"] .modal-close{
    background:#e2e8f0;
    color:#334155;
    border:1px solid #cbd5e1;
    box-shadow:0 8px 18px rgba(148,163,184,.3);
  }
  [data-theme="light"] .modal-close:hover{
    box-shadow:0 12px 24px rgba(148,163,184,.35);
  }
  .option-list{display:flex;flex-direction:column;gap:12px}
  .option-card{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:16px;
    padding:16px;
    border-radius:14px;
    background:linear-gradient(180deg,rgba(15,23,41,.92),rgba(11,18,33,.9));
    border:1px solid rgba(140,160,255,.14);
    cursor:pointer;
    transition:all .25s ease;
  }
  .option-card:hover{
    transform:translateY(-1px);
    box-shadow:0 12px 26px rgba(12,18,32,.55);
  }
  [data-theme="light"] .option-card{
    background:linear-gradient(180deg,rgba(255,255,255,.98),rgba(242,244,248,.95));
    border:1px solid rgba(148,163,184,.4);
    box-shadow:0 12px 26px rgba(15,23,42,.12);
  }
  [data-theme="light"] .option-card:hover{
    box-shadow:0 18px 32px rgba(148,163,184,.28);
  }
  .option-info{display:flex;align-items:center;gap:14px}
  .option-info.no-icon{gap:0}
  .option-icon{
    width:40px;
    height:40px;
    border-radius:12px;
    background:rgba(124,58,237,.18);
    display:grid;
    place-items:center;
    font-size:22px;
  }
  [data-theme="light"] .option-icon{background:rgba(124,58,237,.12)}
  .option-text{display:flex;flex-direction:column;gap:4px}
  .option-title{font-size:15px;font-weight:600;color:var(--txt)}
  [data-theme="light"] .option-title{color:#1e293b}
  .option-subtitle{font-size:12px;color:#9fb0d9}
  [data-theme="light"] .option-subtitle{color:#64748b}
  .option-check{
    width:28px;
    height:28px;
    border-radius:50%;
    border:2px solid rgba(124,148,255,.35);
    display:grid;
    place-items:center;
    font-size:14px;
    font-weight:700;
    color:rgba(124,148,255,.7);
    opacity:0;
    transform:scale(.7);
    transition:all .25s ease;
  }
  .option-card.active{
    background:linear-gradient(90deg,var(--grad1),var(--grad2));
    border-color:transparent;
    box-shadow:0 18px 30px rgba(124,58,237,.38);
  }
  [data-theme="light"] .option-card.active{box-shadow:0 20px 34px rgba(124,58,237,.28)}
  .option-card.active .option-title{color:#fff}
  .option-card.active .option-icon{background:rgba(255,255,255,.22)}
  .option-card.active .option-check{
    opacity:1;
    transform:scale(1);
    color:#fff;
    border-color:rgba(255,255,255,.45);
    background:rgba(255,255,255,.16);
  }
  
  /* Location selection */
  .location-options{display:flex;gap:10px;margin:12px 0}
  .location-option{
    flex:1;text-align:center;padding:12px;background:#0e1624;
    border:1px solid rgba(255,255,255,.08);border-radius:12px;cursor:pointer;
    transition:all 0.2s ease;
    border: none;
    outline: none;
    position:relative;
    overflow:hidden;
    background-repeat:no-repeat;
    background-size:100% 100%;
    -webkit-background-clip:padding-box;
    background-clip:padding-box;
  }
  .location-option.active{background:#17243a;border-color:var(--grad1)}
  [data-theme="light"] .location-option{
    background:#f8fafc;border:1px solid #e2e8f0;color:#475569;
  }
  [data-theme="light"] .location-option.active{
    background:linear-gradient(90deg,var(--grad1),var(--grad2));color:#fff;border-color:transparent;
  }
  
  /* Map for location selection */
  #locationMap{
    height:200px;border-radius:12px;margin:12px 0;border:1px solid rgba(255,255,255,.08);
  }
  [data-theme="light"] #locationMap{border:1px solid #e2e8f0}
  
  /* Address input */
  .address-input{position:relative}
  .address-placeholder{
    position:absolute;top:12px;left:12px;color:#6b7280;
    pointer-events:none;transition:all 0.2s;
  }
  .address-input input:focus + .address-placeholder,
  .address-input input:not(:placeholder-shown) + .address-placeholder{
    display:none;
  }
  
  /* Confirm location button */
  .confirm-location-btn{
    background:linear-gradient(90deg,var(--grad1),var(--grad2));
    color:white;
    border:none;
    padding:12px;
    border-radius:12px;
    font-weight:700;
    cursor:pointer;
    width:100%;
    margin-top:12px;
    transition:all 0.2s ease;
    outline: none;
  }
  .confirm-location-btn:hover{
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(124,58,237,0.3);
  }
  
  /* –ö–Ω–æ–ø–∫–∞ Join */
  .join-btn{
    background:linear-gradient(90deg,var(--grad1),var(--grad2));
    color:white;
    border:none;
    padding:10px 20px;
    border-radius:12px;
    font-weight:700;
    cursor:pointer;
    margin-top:12px;
    width:100%;
    transition:all 0.2s ease;
    outline: none;
  }
  .join-btn:hover{
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(124,58,237,0.3);
  }
  .join-btn:active{
    transform:translateY(0);
  }

  /* Delete pulse button in tooltip */
  .delete-btn{
    background:linear-gradient(90deg, #ef4444, #dc2626);
    color:white;
    border:none;
    padding:8px 16px;
    border-radius:8px;
    font-weight:600;
    cursor:pointer;
    margin-top:8px;
    width:100%;
    transition:all 0.2s ease;
    outline: none;
    font-size:12px;
  }
  .delete-btn:hover{
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(239,68,68,0.3);
  }

  /* –í—Ä–µ–º—è —Å–æ–∑–¥–∞–Ω–∏—è */
  .pulse-time{
    color:#9fb0d9;
    font-size:11px;
    margin:4px 0 8px 0;
    display:flex;
    align-items:center;
    gap:4px;
  justify-content:center;
  text-align:center;
  }
  [data-theme="light"] .pulse-time{color:#64748b}
  .pulse-time::before{
    content:'üïí';
    font-size:10px;
  }

  /* Settings styles */
  .settings-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:16px 0;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  [data-theme="light"] .settings-item{
    border-bottom:1px solid #e2e8f0;
  }
  .settings-item:last-child{
    border-bottom:none;
  }
  .settings-label{
    font-weight:600;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .settings-description{
    color:#9fb0d9;
    font-size:12px;
    margin-top:4px;
  }
  [data-theme="light"] .settings-description{color:#64748b}
  
  .toggle{
    width:44px;
    height:24px;
    background:#1e293b;
    border-radius:12px;
    position:relative;
    cursor:pointer;
    transition:all 0.3s ease;
    border: none;
    outline: none;
  }
  [data-theme="light"] .toggle{background:#cbd5e1}
  .toggle.active{
    background:linear-gradient(90deg,var(--grad1),var(--grad2));
  }
  .toggle::after{
    content:'';
    position:absolute;
    width:20px;
    height:20px;
    background:white;
    border-radius:50%;
    top:2px;
    left:2px;
    transition:all 0.3s ease;
    box-shadow:0 1px 3px rgba(0,0,0,.2);
  }
  .toggle.active::after{
    left:22px;
  }
  
  .slider{
    width:100%;
    margin:16px 0;
    -webkit-appearance:none;
    appearance:none;
    background:#1e293b;
    border-radius:8px;
    height:6px;
    outline: none;
  }
  [data-theme="light"] .slider{background:#cbd5e1}
  .slider::-webkit-slider-thumb{
    -webkit-appearance:none;
    width:20px;
    height:20px;
    border-radius:50%;
    background:linear-gradient(90deg,var(--grad1),var(--grad2));
    cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,.3);
    border: none;
    outline: none;
  }
  .slider-value{
    text-align:center;
    color:var(--txt);
    font-weight:700;
    margin-top:8px;
  }
  .slider-row{display:flex;align-items:center;gap:8px}
  .slider-row .slider-end{font-size:11px;color:var(--muted);white-space:nowrap}

  /* Location selection overlay - –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –°–¢–ò–õ–¨ */
  .location-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.7);
    z-index:1300;
    display:none;
    flex-direction:column;
  }
  .location-overlay.active{
    display:flex;
  }
  .location-header{
    background:var(--panel);
    padding:16px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    border-bottom:1px solid rgba(255,255,255,.1);
  }
  [data-theme="light"] .location-header{
    border-bottom:1px solid #e2e8f0;
  }
  .location-map{
    flex:1;
    position:relative;
    min-height: 0; /* –í–∞–∂–Ω–æ –¥–ª—è flexbox */
    width: 100%;
    height: 100%;
  }
  
  /* –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ Leaflet –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–Ω–∏–º–∞–µ—Ç –≤—Å—é –¥–æ—Å—Ç—É–ø–Ω—É—é –æ–±–ª–∞—Å—Ç—å */
  .location-map .leaflet-container {
    width: 100% !important;
    height: 100% !important;
    min-height: 300px;
  }
  .leaflet-div-icon.location-marker-icon,
  .leaflet-div-icon.me-dot-marker,
  .leaflet-div-icon.location-distance-label{
    background:transparent !important;
    border:none !important;
    box-shadow:none !important;
  }

  .location-marker{
    width:24px;
    height:24px;
    border-radius:50%;
    background:#ef4444;
    border:3px solid rgba(239,68,68,0.9);
    box-shadow:0 0 14px rgba(239,68,68,0.55),0 0 0 8px rgba(239,68,68,0.12);
    position:relative;
    display:block;
    pointer-events:none;
  }
  .location-marker::after{
    content:"";
    position:absolute;
    inset:6px;
    background:rgba(255,255,255,0.9);
    border-radius:50%;
    opacity:0.9;
    pointer-events:none;
  }

  .location-distance-label{
    position:relative;
    width:0 !important;
    height:0 !important;
    pointer-events:none;
  }
  .location-distance-label .distance-text{
    position:absolute;
    top:0;
    left:0;
    transform:translate(-50%, -50%) rotate(var(--angle, 0deg));
    transform-origin:center;
    font-size:14px;
    font-weight:400;
    color:#f8fafc;
    text-shadow:none;
    white-space:nowrap;
    letter-spacing:0.02em;
    pointer-events:none;
  }
  [data-theme="light"] .location-distance-label .distance-text{
    color:#111827;
  }
  [data-theme="dark"] .location-distance-label .distance-text{
    color:#f8fafc;
  }
  /* –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è - –±–µ–∑ –ª–∏—à–Ω–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ */
  .location-instruction{
    position:absolute;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    text-align:center;
    color:white;
    font-weight:600;
    z-index:1000;
    background:rgba(0,0,0,.7);
    padding:8px 16px;
    border-radius:12px;
    backdrop-filter:blur(8px);
    white-space: nowrap;
  }
  [data-theme="light"] .location-instruction{
    color:#1e293b;
    background:rgba(255,255,255,.9);
  }

  /* Help icon */
  .help-icon {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--muted);
    color: var(--bg);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: bold;
    cursor: help;
  }

  /* Visibility options */
  .visibility-options {
    margin-top: 12px;
    padding: 12px;
    background: rgba(255,255,255,.05);
    border-radius: 12px;
    display: none;
  }
  [data-theme="light"] .visibility-options {
    background: rgba(0,0,0,.03);
  }
  .visibility-options.active {
    display: block;
  }
  .visibility-option {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid rgba(255,255,255,.1);
  }
  [data-theme="light"] .visibility-option {
    border-bottom: 1px solid rgba(0,0,0,.1);
  }
  .visibility-option:last-child {
    border-bottom: none;
  }
  .visibility-label {
    font-weight: 500;
    font-size: 14px;
  }
  .visibility-description {
    color: var(--muted);
    font-size: 11px;
    margin-top: 2px;
  }

  /* Language selector */
  .language-selector {
    display: flex;
    gap: 8px;
    margin-top: 8px;
  }
  .language-option {
    flex: 1;
    padding: 8px 12px;
    background: #0e1624;
    border: none; /* match chip style in dark mode to avoid side lines */
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
    font-size: 12px;
    font-weight: 700; /* match chip weight */
    color: var(--muted);
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
    -webkit-background-clip: padding-box;
    background-clip: padding-box;
    background-repeat: no-repeat;
    background-size: 100% 100%;
    box-shadow: none;
  }
  [data-theme="light"] .language-option {
    background: #f1f5f9;
    border: 1px solid #e2e8f0; /* like chip in light mode */
    color: #64748b;
  }
  .language-option.active {
    /* Match chip active in dark mode */
    background:#17243a;
    color:#fff;
    border:none;
  }
  [data-theme="light"] .language-option.active{
    /* Match chip active in light mode */
    background: linear-gradient(90deg,var(--grad1),var(--grad2));
    background-size:100% 100%;
    -webkit-background-clip: padding-box;
    background-clip: padding-box;
    color:#fff;
    border-color:transparent;
  }

  /* Ensure rounded elements render cleanly on some Android WebViews */
  .chip, .language-option, .location-option {
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
  }
  
  /* Welcome screen */
  #welcome-screen {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background:
      radial-gradient(120% 150% at 50% 12%, rgba(124, 58, 237, 0.22), transparent 70%),
      linear-gradient(160deg, rgba(11, 18, 32, 0.18), rgba(11, 18, 32, 0.62)),
      url('https://raw.githubusercontent.com/Sikafanka/radius5-map/main/images/%D0%BB%D0%BE%D0%B3%D0%BE.jpg') center/cover no-repeat,
      var(--bg);
    animation: screenFadeOut 0.8s ease-in-out 4s forwards;
    z-index: 1200;
    overflow: hidden;
  }

  #welcome-screen::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(145deg, rgba(8, 12, 20, 0.22), rgba(8, 12, 20, 0.48));
  }

  #welcome-screen::after {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(100% 120% at 50% 20%, rgba(34, 211, 238, 0.18), transparent 65%),
      linear-gradient(200deg, rgba(124, 58, 237, 0.16), transparent 55%);
    mix-blend-mode: screen;
    pointer-events: none;
  }

  .welcome-inner {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    gap: 10px;
    width: min(88vw, 360px);
  }

  .welcome-logo {
    width: 116px;
    height: 116px;
    border-radius: 50%;
    object-fit: cover;
    filter: drop-shadow(0 16px 45px rgba(124, 58, 237, 0.55));
    opacity: 0;
    transform: scale(0.8);
    animation: logoAppear 1s ease-out 0.3s forwards;
  }

  .welcome-title {
    height: 58px;
    margin-bottom: 14px;
    opacity: 0;
    transform: translateY(20px);
    animation: titleAppear 0.8s ease-out 0.6s forwards;
  }

  .welcome-tagline {
    height: 26px;
    margin-bottom: 32px;
    opacity: 0;
    transform: translateY(20px);
    animation: taglineAppear 0.8s ease-out 0.9s forwards;
  }

  .progress-wrapper {
    width: 100%;
    max-width: 280px;
    opacity: 0;
    transform: translateY(20px);
    animation: containerAppear 0.8s ease-out 1.2s forwards;
  }

  .progress-track {
    position: relative;
    width: 100%;
    height: 4px;
    background: rgba(241, 245, 249, 0.15);
    border-radius: 999px;
    overflow: hidden;
  }

  .progress-bar {
    position: absolute;
    inset: 0;
    width: 0%;
    background: linear-gradient(90deg, var(--grad1), var(--grad2));
    border-radius: inherit;
    animation: progressLoad 3.5s ease-in-out 1.5s forwards;
  }

  .loading-percent {
    margin-top: 14px;
    font-size: 14px;
    font-weight: 700;
    letter-spacing: 0.06em;
    opacity: 0;
    transform: translateY(20px);
    animation: containerAppear 0.8s ease-out 1.2s forwards;
  }

  .welcome-credits {
    position: absolute;
    bottom: 28px;
    left: 50%;
    transform: translateX(-50%);
    height: 16px;
    opacity: 0;
    animation: creditsAppear 0.8s ease-out 1.8s forwards;
  }

  @keyframes logoAppear {
    0% {
      opacity: 0;
      transform: scale(0.8);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  @keyframes titleAppear {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes taglineAppear {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes containerAppear {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes creditsAppear {
    0% {
      opacity: 0;
      transform: translate(-50%, 10px);
    }
    100% {
      opacity: 1;
      transform: translate(-50%, 0);
    }
  }

  @keyframes progressLoad {
    0% {
      width: 0%;
    }
    100% {
      width: 100%;
    }
  }

  @keyframes screenFadeOut {
    0% {
      opacity: 1;
      visibility: visible;
    }
    99% {
      opacity: 0;
      visibility: visible;
    }
    100% {
      opacity: 0;
      visibility: hidden;
    }
  }

  @media (max-width: 768px) {
    .welcome-inner {
      gap: 8px;
      width: min(92vw, 320px);
    }

    .welcome-logo {
      width: 96px;
      height: 96px;
    }

    .welcome-title {
      height: 48px;
      margin-bottom: 12px;
    }

    .welcome-tagline {
      height: 22px;
      margin-bottom: 24px;
    }

    .progress-wrapper {
      max-width: 220px;
    }

    .loading-percent {
      font-size: 12px;
      margin-top: 12px;
    }

    .welcome-credits {
      bottom: 20px;
      height: 16px;
    }
  }

</style>
</head>
<body>
<div id="welcome-screen">
  <div class="welcome-inner">
    <img
      class="welcome-logo"
      src="https://raw.githubusercontent.com/Sikafanka/radius5-map/main/images/logo.png"
      alt="RADIUS 5 Logo"
    />
    <img
      class="welcome-title"
      src="https://raw.githubusercontent.com/Sikafanka/radius5-map/main/images/RADIUS%205.png"
      alt="RADIUS 5 Title"
    />
    <img
      class="welcome-tagline"
      src="https://raw.githubusercontent.com/Sikafanka/radius5-map/main/images/Stop%20Scrolling%20_%20Start%20Living.png"
      alt="Stop Scrolling / Start Living"
    />
    <div class="progress-wrapper">
      <div class="progress-track">
        <div class="progress-bar"></div>
      </div>
      <div class="loading-percent">0%</div>
    </div>
  </div>
  <img
    class="welcome-credits"
    src="https://raw.githubusercontent.com/Sikafanka/radius5-map/main/images/created%20by%20_%20justBaha.png"
    alt="created by / justBaha"
  />
</div>
<div id="app">
  <div id="map"></div>

  <div id="ui">
    <div class="topbar">
      <div class="chips" id="chips"></div>
    </div>
    
    <!-- –ö–Ω–æ–ø–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ —Å–ø—Ä–∞–≤–∞ –æ—Ç —Ç–æ–ø–±–∞—Ä–∞ -->
    <button class="geolocation-btn" id="geolocationBtn" title="–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –º–æ–µ–π –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏">
      <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
        <circle cx="12" cy="10" r="3"></circle>
      </svg>
    </button>
  </div>

  <div class="profile-btn" id="profileBtn" title="–ü—Ä–æ—Ñ–∏–ª—å">
    <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
      <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
      <circle cx="12" cy="7" r="4"></circle>
    </svg>
  </div>

  <div class="cta" id="createBtn">+ –°–û–ó–î–ê–¢–¨ –ü–£–õ–¨–°</div>
  
  <!-- –ö–Ω–æ–ø–∫–∞ Delete - –≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º–∞ –¥–ª—è —Å–æ–∑–¥–∞—Ç–µ–ª—è –ø—É–ª—å—Å–∞ -->
  <button class="delete-btn-pulse" id="deletePulseBtn" title="–£–¥–∞–ª–∏—Ç—å –ø—É–ª—å—Å" style="display: none;">
    <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 6h18"></path>
      <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path>
      <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
      <line x1="10" y1="11" x2="10" y2="17"></line>
      <line x1="14" y1="11" x2="14" y2="17"></line>
    </svg>
  </button>
  
  <div class="settings-btn" id="settingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">
    <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
      <g transform="translate(12 12)">
        <circle r="7.2"></circle><rect x="-1" y="-11.2" width="2" height="3.4" rx="1"/>
        <rect x="-1" y="-11.2" width="2" height="3.4" rx="1" transform="rotate(45)"/>
        <rect x="-1" y="-11.2" width="2" height="3.4" rx="1" transform="rotate(90)"/>
        <rect x="-1" y="-11.2" width="2" height="3.4" rx="1" transform="rotate(135)"/>
        <rect x="-1" y="-11.2" width="2" height="3.4" rx="1" transform="rotate(180)"/>
        <rect x="-1" y="-11.2" width="2" height="3.4" rx="1" transform="rotate(225)"/>
        <rect x="-1" y="-11.2" width="2" height="3.4" rx="1" transform="rotate(270)"/>
        <rect x="-1" y="-11.2" width="2" height="3.4" rx="1" transform="rotate(315)"/>
        <circle r="3.4"></circle>
      </g>
    </svg>
  </div>

  <!-- Location Selection Overlay - –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô -->
  <div class="location-overlay" id="locationOverlay">
    <div class="location-header">
      <h3 style="margin:0">–í—ã–±–µ—Ä–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é</h3>
      <div class="btn" id="cancelLocationSelect">–û—Ç–º–µ–Ω–∞</div>
    </div>
    <div class="location-map" id="locationSelectMap">
      <div class="location-instruction">–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –ª–æ–∫–∞—Ü–∏–∏</div>
    </div>
    <!-- –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±—Ä–∞–Ω–∞ –ª–∏—à–Ω—è—è –æ–±–µ—Ä—Ç–∫–∞ —Å –±–µ–ª—ã–º —Ñ–æ–Ω–æ–º -->
    <div style="padding:16px;background:transparent">
      <button class="confirm-location-btn" id="confirmLocationSelect">‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ª–æ–∫–∞—Ü–∏—é</button>
    </div>
  </div>

  <!-- Modal create pulse -->
  <div class="modal" id="createModal">
    <div class="sheet" id="createSheet">
      <h3>–°–æ–∑–¥–∞—Ç—å –ø—É–ª—å—Å</h3>
      
      <div class="row">
        <div class="option-field" id="categoryField">
          <div>
            <div class="field-label" id="categoryFieldLabel">–ö–∞—Ç–µ–≥–æ—Ä–∏—è</div>
            <div class="field-value" id="categoryDisplay">üèÉ –°–ø–æ—Ä—Ç</div>
          </div>
        </div>
      </div>
      
      <!-- –í—ã–±–æ—Ä –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ª—é–¥–µ–π –æ—Ç 1 –¥–æ 5 -->
      <div class="row">
        <div class="option-field" id="peopleField">
          <div>
            <div class="field-label" id="peopleFieldLabel">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—é–¥–µ–π</div>
            <div class="field-value" id="peopleDisplay">5 —á–µ–ª–æ–≤–µ–∫</div>
          </div>
        </div>
      </div>
      
      <div class="row">
        <textarea id="msg" rows="3" class="input" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ..."></textarea>
      </div>
      
      <div class="row">
        <div style="width:100%">
          <div style="margin-bottom:8px; font-weight:600" id="selectLocationLabel">–í—ã–±–µ—Ä–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é</div>
          <div class="location-options">
            <div class="location-option" id="customLocation">–í—ã–±—Ä–∞—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ</div>
            <div class="location-option active" id="addressLocation">–£–∫–∞–∑–∞—Ç—å –∞–¥—Ä–µ—Å</div>
          </div>
        </div>
      </div>
      
      <div id="addressInputContainer">
        <div class="address-input">
          <input type="text" id="addressInput" class="input" placeholder="" style="padding-left:12px">
          <div class="address-placeholder">–≤–≤–µ–¥–∏—Ç–µ —Ç–æ—á–Ω—ã–π –∞–¥—Ä–µ—Å</div>
        </div>
      </div>
      
      <div id="locationMapContainer" style="display:none">
        <div class="hint">–í—ã–±—Ä–∞–Ω–Ω–∞—è –ª–æ–∫–∞—Ü–∏—è –±—É–¥–µ—Ç –ø–æ–∫–∞–∑–∞–Ω–∞ –∑–¥–µ—Å—å –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –Ω–∞ –∫–∞—Ä—Ç–µ</div>
      </div>
      
      <div class="footer">
        <div class="btn" id="cancelCreate">–û—Ç–º–µ–Ω–∞</div>
        <div class="btn primary" id="saveCreate">–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å</div>
      </div>
    </div>
  </div>

  <div class="modal option-modal" id="categoryModal">
    <div class="sheet option-sheet">
      <div class="option-header">
        <h3 id="categoryModalTitle">–í—ã–±–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏</h3>
        <div class="modal-close" id="closeCategoryModal">‚úï</div>
      </div>
      <div class="option-list" id="categoryOptions"></div>
    </div>
  </div>

  <div class="modal option-modal" id="peopleModal">
    <div class="sheet option-sheet">
      <div class="option-header">
        <h3 id="peopleModalTitle">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—é–¥–µ–π</h3>
        <div class="modal-close" id="closePeopleModal">‚úï</div>
      </div>
      <div class="option-list" id="peopleOptions"></div>
    </div>
  </div>

  <!-- Modal Settings -->
  <div class="modal" id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="sheet" id="settingsSheet">
      <div class="sheet-header" id="settingsHeader">
        <h3 id="settingsTitle">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
        <button type="button" class="sheet-close" id="settingsClose" aria-label="–ó–∞–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏">‚úï</button>
      </div>
      <div class="sheet-body" id="settingsSheetBody">
      
      <div class="settings-item">
        <div>
          <div class="settings-label">–¢—ë–º–Ω–∞—è —Ç–µ–º–∞</div>
          <div class="settings-description">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—ë–º–Ω—É—é —Ç–µ–º—É –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –±–∞—Ç–∞—Ä–µ–∏</div>
        </div>
        <div class="toggle active" id="darkModeToggle"></div>
      </div>
      
      <div class="settings-item">
        <div>
          <div class="settings-label">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –º–æ—é –ª–æ–∫–∞—Ü–∏—é</div>
          <div class="settings-description">–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –≤–∞—à—É –ª–æ–∫–∞—Ü–∏—é –Ω–∞ –∫–∞—Ä—Ç–µ</div>
        </div>
        <div class="toggle active" id="showLocationToggle"></div>
      </div>

      <div class="settings-item">
        <div>
          <div class="settings-label">–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ</div>
          <div class="settings-description">–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –≤–∞—à–µ–π –ª–æ–∫–∞—Ü–∏–∏ –¥–æ –∫–∞–∂–¥–æ–≥–æ –ø—É–ª—å—Å–∞</div>
        </div>
        <div class="toggle" id="showDistanceToggle"></div>
      </div>
      
      <div class="settings-item">
        <div>
          <div class="settings-label">–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø—É–ª—å—Å–∞—Ö</div>
          <div class="settings-description">–ü–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –ø—É–ª—å—Å–∞—Ö —Ä—è–¥–æ–º</div>
        </div>
        <div class="toggle active" id="notificationsToggle"></div>
      </div>
      
      <div class="settings-item">
        <div>
          <div class="settings-label">–†–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞</div>
          <div class="settings-description">–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∫–∞–∫ –¥–∞–ª–µ–∫–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø—É–ª—å—Å—ã</div>
        </div>
        <div style="width:220px">
          <div class="slider-row">
            <span class="slider-end">0 –∫–º</span>
            <input type="range" min="0" max="10" value="5" class="slider" id="radiusSlider">
            <span class="slider-end">10 –∫–º</span>
          </div>
          <div class="slider-value" id="radiusValue">5 –∫–º</div>
        </div>
      </div>
      
      <div class="settings-item">
        <div>
          <div class="settings-label">–í–∏–¥–∏–º–æ—Å—Ç—å –ø—É–ª—å—Å–æ–≤</div>
          <div class="settings-description">–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ –∫—Ç–æ –º–æ–∂–µ—Ç –≤–∏–¥–µ—Ç—å –≤–∞—à–∏ –ø—É–ª—å—Å—ã</div>
        </div>
        <div class="toggle" id="pulseVisibilityToggle"></div>
      </div>
      
      <div class="visibility-options" id="visibilityOptions">
        <div class="visibility-option">
          <div>
            <div class="visibility-label">–ü—É–±–ª–∏—á–Ω—ã–π</div>
            <div class="visibility-description">–í–∏–¥—è—Ç –≤—Å–µ –≤ —Ä–∞–¥–∏—É—Å–µ</div>
          </div>
          <div class="toggle active" data-visibility="public"></div>
        </div>
        <div class="visibility-option">
          <div>
            <div class="visibility-label">–õ–æ–∫–∞–ª—å–Ω—ã–π</div>
            <div class="visibility-description">–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä—è–¥–æ–º –∑–∞ 24—á</div>
          </div>
          <div class="toggle" data-visibility="local"></div>
        </div>
        <div class="visibility-option">
          <div>
            <div class="visibility-label">–ü—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞</div>
            <div class="visibility-description">–¢–æ–ª—å–∫–æ –ø–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é</div>
          </div>
          <div class="toggle" data-visibility="private"></div>
        </div>
      </div>
      
      <div class="settings-item" id="languageSetting">
        <div>
          <div class="settings-label">–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</div>
          <div class="settings-description">–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</div>
        </div>
      </div>
      
      <div class="language-selector">
        <div class="language-option active" data-lang="ru">–†—É—Å—Å–∫–∏–π</div>
        <div class="language-option" data-lang="en">English</div>
        <div class="language-option" data-lang="kz">“ö–∞–∑–∞“õ—à–∞</div>
      </div>
      
      <div class="settings-item">
        <div>
          <div class="settings-label">–ê–≤—Ç–æ-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã</div>
          <div class="settings-description">–û–±–Ω–æ–≤–ª—è—Ç—å –ø—É–ª—å—Å—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏</div>
        </div>
        <div class="toggle" id="autoRefreshToggle"></div>
      </div>
      
      <div class="settings-item">
        <div>
          <div class="settings-label">–í–∏–±—Ä–∞—Ü–∏—è</div>
          <div class="settings-description">–¢–∞–∫—Ç–∏–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å</div>
        </div>
        <div class="toggle active" id="vibrationToggle"></div>
      </div>
      
      </div> <!-- sheet-body -->
    </div>
  </div>
</div>

<script>
// üîí –ë–ï–ó–û–ü–ê–°–ù–ê–Ø –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø - –ö–õ–Æ–ß–ò –ò–ó config.js
if (!window.SUPABASE_URL || !window.SUPABASE_ANON_KEY) {
  console.error('‚ùå Supabase –∫–ª—é—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã! –ü—Ä–æ–≤–µ—Ä—å —Ñ–∞–π–ª config.js');
  alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –°–≤—è–∂–∏—Å—å —Å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º.');
} else {
  // ‚úÖ –ö–ª—é—á–∏ –µ—Å—Ç—å - –∑–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
  const db = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
  console.log('‚úÖ Supabase –ø–æ–¥–∫–ª—é—á–µ–Ω –±–µ–∑–æ–ø–∞—Å–Ω–æ!');
  
  // –î–ê–õ–ï–ï –í–ï–°–¨ –¢–í–û–ô –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ô –ö–û–î –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
  const welcomeScreen = document.getElementById('welcome-screen');
  
  if (welcomeScreen) {
    const progressText = welcomeScreen.querySelector('.loading-percent');
    const startDelay = 1500;
    const duration = 3500;
    const previousOverflow = document.body.style.overflow;

    const startProgressCounter = () => {
      const startedAt = performance.now();

      const update = (timestamp) => {
        const elapsed = timestamp - startedAt;
        const progress = Math.min(elapsed / duration, 1);

        if (progressText) {
          progressText.textContent = `${Math.round(progress * 100)}%`;
        }

        if (progress < 1) {
          requestAnimationFrame(update);
        }
      };

      requestAnimationFrame(update);
    };

    setTimeout(startProgressCounter, startDelay);

    welcomeScreen.addEventListener('animationend', (event) => {
      if (event.animationName === 'screenFadeOut') {
        welcomeScreen.remove();
        document.body.style.overflow = previousOverflow;
      }
    });
  }

  /* -------------------- CONFIG -------------------- */
  // –ö–ª—é—á–∏ —É–∂–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ config.js
  
  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–µ—à —Å—Ö–µ–º—ã
  setTimeout(async () => {
    try {
      const { data, error } = await db.from('pulses').select('people_count').limit(1);
      console.log('Schema cache refreshed');
    } catch (e) {
      console.log('Cache refresh attempt');
    }
  }, 1000);

  /* -------------------- LANGUAGE MANAGEMENT -------------------- */
  const translations = {
    ru: {
      createPulse: "–°–û–ó–î–ê–¢–¨ –ü–£–õ–¨–°",
      createPulseTitle: "–°–æ–∑–¥–∞—Ç—å –ø—É–ª—å—Å",
      categoryLabel: "–ö–∞—Ç–µ–≥–æ—Ä–∏—è",
      categorySelectTitle: "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
      peopleLabel: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—é–¥–µ–π",
      peopleSelectTitle: "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—é–¥–µ–π",
      sport: "–°–ø–æ—Ä—Ç",
      games: "–ò–≥—Ä—ã", 
      art: "–ò—Å–∫—É—Å—Å—Ç–≤–æ",
      social: "–°–æ—Ü–∏–∞–ª—å–Ω–æ–µ",
      creative: "–ö—Ä–µ–∞—Ç–∏–≤",
      chill: "–û—Ç–¥—ã—Ö",
      active: "–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å",
      dating: "–ó–Ω–∞–∫–æ–º—Å—Ç–≤–∞",
      education: "–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ",
      animal: "–ñ–∏–≤–æ—Ç–Ω—ã–µ",
      help: "–ü–æ–º–æ—â—å",
      selectLocation: "–í—ã–±–µ—Ä–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é",
      chooseOnMap: "–í—ã–±—Ä–∞—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ",
      writeAddress: "–£–∫–∞–∑–∞—Ç—å –∞–¥—Ä–µ—Å",
      enterAddress: "–≤–≤–µ–¥–∏—Ç–µ —Ç–æ—á–Ω—ã–π –∞–¥—Ä–µ—Å",
      cancel: "–û—Ç–º–µ–Ω–∞",
      publish: "–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å",
      settings: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
      darkMode: "–¢—ë–º–Ω–∞—è —Ç–µ–º–∞",
      showLocation: "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –º–æ—é –ª–æ–∫–∞—Ü–∏—é",
      showDistance: "–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ",
      notifications: "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø—É–ª—å—Å–∞—Ö",
      searchRadius: "–†–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞",
      autoRefresh: "–ê–≤—Ç–æ-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã",
      vibration: "–í–∏–±—Ä–∞—Ü–∏—è",
      close: "–ó–∞–∫—Ä—ã—Ç—å",
      save: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
      join: "–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è",
      delete: "–£–¥–∞–ª–∏—Ç—å",
      selectLocationTitle: "–í—ã–±–µ—Ä–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é",
      tapToSelect: "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –ª–æ–∫–∞—Ü–∏–∏",
      confirmLocation: "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ª–æ–∫–∞—Ü–∏—é",
      yourPulse: "–í–∞—à –ø—É–ª—å—Å",
      deleteConfirm: "–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –ø—É–ª—å—Å?",
      pulseVisibility: "–í–∏–¥–∏–º–æ—Å—Ç—å –ø—É–ª—å—Å–æ–≤",
      language: "–Ø–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞",
      deletePulse: "–£–¥–∞–ª–∏—Ç—å –ø—É–ª—å—Å",
      all: "–í—Å–µ",
      peopleCount: "—á–µ–ª–æ–≤–µ–∫",
      peopleCount2: "—á–µ–ª–æ–≤–µ–∫–∞",
      locationHint: "–í—ã–±—Ä–∞–Ω–Ω–∞—è –ª–æ–∫–∞—Ü–∏—è –±—É–¥–µ—Ç –ø–æ–∫–∞–∑–∞–Ω–∞ –∑–¥–µ—Å—å –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –Ω–∞ –∫–∞—Ä—Ç–µ",
      writeMessage: "–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...",
      justNow: "—Ç–æ–ª—å–∫–æ —á—Ç–æ",
      minutesAgo: "–º –Ω–∞–∑–∞–¥",
      hoursAgo: "—á –Ω–∞–∑–∞–¥",
      daysAgo: "–¥ –Ω–∞–∑–∞–¥",
      myGeolocation: "–ú–û–Ø –ì–ï–û–õ–û–ö–ê–¶–ò–Ø",
      returnToLocation: "–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –º–æ–µ–π –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏",
      selectLocationLabel: "–í—ã–±–µ—Ä–∏—Ç–µ –ª–æ–∫–∞—Ü–∏—é",
      public: "–ü—É–±–ª–∏—á–Ω—ã–π",
      local: "–õ–æ–∫–∞–ª—å–Ω—ã–π",
      private: "–ü—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞",
      publicDesc: "–í–∏–¥—è—Ç –≤—Å–µ –≤ —Ä–∞–¥–∏—É—Å–µ",
      localDesc: "–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä—è–¥–æ–º –∑–∞ 24—á",
      privateDesc: "–¢–æ–ª—å–∫–æ –ø–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é",
      distanceUnit: "–∫–º",
      distanceKmLabel: "–∫–º",
      distanceMetersLabel: "–º",
      deleteError: "–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏",
      createError: "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø—É–ª—å—Å–∞",
      errorUnknown: "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
      errorGeneric: "–æ—à–∏–±–∫–∞",
      joinPreview: "üéâ {join}!\\n\\n\"{message}\"\\n\\n–í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ —ç—Ç–æ –æ—Ç–∫—Ä—ã–ª–æ –±—ã —á–∞—Ç —Å —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º!"
    },
    en: {
      createPulse: "CREATE PULSE",
      createPulseTitle: "Create Pulse",
      categoryLabel: "Category",
      categorySelectTitle: "Choose Category",
      peopleLabel: "Number of people",
      peopleSelectTitle: "Choose number of people",
      sport: "Sport",
      games: "Games",
      art: "Art",
      social: "Social", 
      creative: "Creative",
      chill: "Chill",
      active: "Active",
      dating: "Dating",
      education: "Education",
      animal: "Animal",
      help: "Help",
      selectLocation: "Select location",
      chooseOnMap: "Choose on Map",
      writeAddress: "Write Address",
      enterAddress: "write correct address",
      cancel: "Cancel",
      publish: "Publish",
      settings: "Settings",
      darkMode: "Dark Mode",
      showLocation: "Show My Location",
      showDistance: "Show Distance",
      notifications: "Pulse Notifications",
      searchRadius: "Search Radius",
      autoRefresh: "Auto-refresh Map",
      vibration: "Vibration",
      close: "Close",
      save: "Save",
      join: "Join",
      delete: "Delete",
      selectLocationTitle: "Select Location",
      tapToSelect: "Tap on the map to select location",
      confirmLocation: "Confirm This Location",
      yourPulse: "Your pulse",
      deleteConfirm: "Delete this pulse?",
      pulseVisibility: "Pulse Visibility",
      language: "Interface Language",
      deletePulse: "Delete Pulse",
      all: "All",
      peopleCount: "person",
      peopleCount2: "people",
      locationHint: "Selected location will be shown here after choosing on the map",
      writeMessage: "Write your message...",
      justNow: "just now",
      minutesAgo: "m ago",
      hoursAgo: "h ago",
      daysAgo: "d ago",
      myGeolocation: "MY LOCATION",
      returnToLocation: "Return to my geolocation",
      selectLocationLabel: "Select location",
      public: "Public",
      local: "Local",
      private: "Private link",
      publicDesc: "Visible to everyone nearby",
      localDesc: "Only active people nearby in the last 24h",
      privateDesc: "Invite only",
      distanceUnit: "km",
      distanceKmLabel: "km",
      distanceMetersLabel: "m",
      deleteError: "Error deleting pulse",
      createError: "Error creating pulse",
      errorUnknown: "unknown",
      errorGeneric: "error",
      joinPreview: "üéâ {join}!\\n\\n\"{message}\"\\n\\nIn the real app this would open a chat with the creator!"
    },
    kz: {
      createPulse: "–ü–£–õ–¨–°–¢–´ –ñ–ê–†–ò–Ø–õ–ê–£",
      createPulseTitle: "–ü—É–ª—å—Å –∂–∞—Å–∞—É",
      categoryLabel: "–°–∞–Ω–∞—Ç",
      categorySelectTitle: "–°–∞–Ω–∞—Ç—Ç—ã —Ç–∞“£–¥–∞“£—ã–∑",
      peopleLabel: "–ê–¥–∞–º —Å–∞–Ω—ã",
      peopleSelectTitle: "–ê–¥–∞–º —Å–∞–Ω—ã–Ω —Ç–∞“£–¥–∞“£—ã–∑",
      sport: "–°–ø–æ—Ä—Ç",
      games: "–û–π—ã–Ω–¥–∞—Ä",
      art: "”®–Ω–µ—Ä",
      social: "”ò–ª–µ—É–º–µ—Ç—Ç—ñ–∫",
      creative: "–®—ã“ì–∞—Ä–º–∞—à—ã–ª—ã“õ",
      chill: "–î–µ–º–∞–ª—É",
      active: "–ë–µ–ª—Å–µ–Ω–¥—ñ–ª—ñ–∫",
      dating: "–¢–∞–Ω—ã—Å—É",
      education: "–ë—ñ–ª—ñ–º",
      animal: "–ñ–∞–Ω—É–∞—Ä–ª–∞—Ä",
      help: "–ö”©–º–µ–∫",
      selectLocation: "–û—Ä–Ω–∞–ª–∞—Å—É–¥—ã —Ç–∞“£–¥–∞“£—ã–∑",
      chooseOnMap: "–ö–∞—Ä—Ç–∞–¥–∞–Ω —Ç–∞“£–¥–∞—É",
      writeAddress: "–ú–µ–∫–µ–Ω–∂–∞–π–¥—ã –∫”©—Ä—Å–µ—Ç—É",
      enterAddress: "–¥”ô–ª –º–µ–∫–µ–Ω–∂–∞–π–¥—ã –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑",
      cancel: "–ë–æ–ª–¥—ã—Ä–º–∞—É",
      publish: "–ñ–∞—Ä–∏—è–ª–∞—É",
      settings: "–ü–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä",
      darkMode: "“ö–∞—Ä–∞“£“ì—ã —Ä–µ–∂–∏–º",
      showLocation: "–ú–µ–Ω—ñ“£ –æ—Ä–Ω–∞–ª–∞—Å—É—ã–º–¥—ã –∫”©—Ä—Å–µ—Ç—É",
      showDistance: "“ö–∞—à—ã“õ—Ç—ã“õ—Ç—ã –∫”©—Ä—Å–µ—Ç—É",
      notifications: "–ü—É–ª—å—Å —Ç—É—Ä–∞–ª—ã —Ö–∞–±–∞—Ä–ª–∞–Ω–¥—ã—Ä—É–ª–∞—Ä",
      searchRadius: "–Ü–∑–¥–µ—É —Ä–∞–¥–∏—É—Å—ã",
      autoRefresh: "–ö–∞—Ä—Ç–∞–Ω—ã –∞–≤—Ç–æ-–∂–∞“£–∞—Ä—Ç—É",
      vibration: "–î—ñ—Ä—ñ–ª",
      close: "–ñ–∞–±—É",
      save: "–°–∞“õ—Ç–∞—É",
      join: "“ö–æ—Å—ã–ª—É",
      delete: "–ñ–æ—é",
      selectLocationTitle: "–û—Ä–Ω–∞–ª–∞—Å—É–¥—ã —Ç–∞“£–¥–∞“£—ã–∑",
      tapToSelect: "–û—Ä–Ω–∞–ª–∞—Å—É–¥—ã —Ç–∞“£–¥–∞—É “Ø—à—ñ–Ω –∫–∞—Ä—Ç–∞–Ω—ã –±–∞—Å—ã“£—ã–∑",
      confirmLocation: "–û—Ä–Ω–∞–ª–∞—Å—É–¥—ã —Ä–∞—Å—Ç–∞—É",
      yourPulse: "–°—ñ–∑–¥—ñ“£ –ø—É–ª—å—Å—ñ“£—ñ–∑",
      deleteConfirm: "–ë“±–ª –ø—É–ª—å—Å—Ç—ñ –∂–æ—é –∫–µ—Ä–µ–∫ –ø–µ?",
      pulseVisibility: "–ü—É–ª—å—Å—Ç–µ—Ä–¥—ñ“£ –∫”©—Ä—ñ–Ω—É—ñ",
      language: "–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Ç—ñ–ª—ñ",
      deletePulse: "–ü—É–ª—å—Å—Ç—ñ –∂–æ—é",
      all: "–ë–∞—Ä–ª—ã“ì—ã",
      peopleCount: "–∞–¥–∞–º",
      peopleCount2: "–∞–¥–∞–º",
      locationHint: "–¢–∞“£–¥–∞–ª“ì–∞–Ω –æ—Ä–Ω–∞–ª–∞—Å—É –∫–∞—Ä—Ç–∞–¥–∞–Ω —Ç–∞“£–¥–∞“ì–∞–Ω–Ω–∞–Ω –∫–µ–π—ñ–Ω –æ—Å—ã –∂–µ—Ä–¥–µ –∫”©—Ä—Å–µ—Ç—ñ–ª–µ–¥—ñ",
      writeMessage: "–•–∞–±–∞—Ä–ª–∞–º–∞“£—ã–∑–¥—ã –∂–∞–∑—ã“£—ã–∑...",
      justNow: "–¥”ô–ª “õ–∞–∑—ñ—Ä",
      minutesAgo: "–º –±“±—Ä—ã–Ω",
      hoursAgo: "—Å–∞“ì –±“±—Ä—ã–Ω",
      daysAgo: "–∫“Ø–Ω –±“±—Ä—ã–Ω",
      myGeolocation: "–ú–ï–ù–Ü“¢ –û–†–ù–ê–õ–ê–°–£–´–ú",
      returnToLocation: "–ú–µ–Ω—ñ“£ –æ—Ä–Ω–∞–ª–∞—Å—É—ã–º–∞ –æ—Ä–∞–ª—É",
      selectLocationLabel: "–û—Ä–Ω–∞–ª–∞—Å—É–¥—ã —Ç–∞“£–¥–∞“£—ã–∑",
      public: "–ñ–∞–ª–ø—ã“ì–∞ –∞—à—ã“õ",
      local: "–ñ–µ—Ä–≥—ñ–ª—ñ–∫—Ç—ñ",
      private: "–ñ–µ–∫–µ —Å—ñ–ª—Ç–µ–º–µ",
      publicDesc: "–†–∞–¥–∏—É—Å—Ç–∞“ì—ã –±–∞—Ä–ª—ã“õ –∞–¥–∞–º–¥–∞—Ä –∫”©—Ä–µ–¥—ñ",
      localDesc: "–°–æ“£“ì—ã 24 —Å–∞“ì–∞—Ç—Ç–∞“ì—ã –∂–∞“õ—ã–Ω –±–µ–ª—Å–µ–Ω–¥—ñ–ª–µ—Ä “ì–∞–Ω–∞",
      privateDesc: "–¢–µ–∫ —à–∞“õ—ã—Ä—É –∞—Ä“õ—ã–ª—ã",
      distanceUnit: "–∫–º",
      distanceKmLabel: "–∫–º",
      distanceMetersLabel: "–º",
      deleteError: "–ü—É–ª—å—Å—Ç—ñ –∂–æ—é “õ–∞—Ç–µ—Å—ñ",
      createError: "–ü—É–ª—å—Å—Ç—ñ –∂–∞—Å–∞—É “õ–∞—Ç–µ—Å—ñ",
      errorUnknown: "–±–µ–ª–≥—ñ—Å—ñ–∑",
      errorGeneric: "“õ–∞—Ç–µ",
      joinPreview: "üéâ {join}!\\n\\n\"{message}\"\\n\\n–ù–∞“ì—ã–∑ “õ–æ—Å—ã–º—à–∞–¥–∞ –±“±–ª “±–π—ã–º–¥–∞—Å—Ç—ã—Ä—É—à—ã“ì–∞ —á–∞—Ç –∞—à–∞—Ä –µ–¥—ñ!"
    }
  };

  // –ö–∞—Ç–µ–≥–æ—Ä–∏–π–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤
    const categoryHints = {
    ru: {
      'sport': '–ë–∞—Å–∫–µ—Ç–±–æ–ª –≤ –ø–∞—Ä–∫–µ, –∫—Ç–æ —Å–æ –º–Ω–æ–π?',
      'games': '–¢—É—Ä–Ω–∏—Ä –ø–æ Mario Kart —É –º–µ–Ω—è –¥–æ–º–∞!',
      'art': '–°–µ—Å—Å–∏—è —Å–∫–µ—Ç—á–∏–Ω–≥–∞ –≤ –ø–∞—Ä–∫–µ',
      'social': '–ö–æ—Ñ–µ –∏ –æ–±—â–µ–Ω–∏–µ –≤ Starbucks',
      'creative': '–ë—Ä–µ–π–Ω—à—Ç–æ—Ä–º–∏–Ω–≥ –Ω–æ–≤—ã—Ö –∏–¥–µ–π –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞',
      'chill': '–ù–∞–±–ª—é–¥–µ–Ω–∏–µ –∑–∞ –∑–∞–∫–∞—Ç–æ–º –Ω–∞ –ø–ª—è–∂–µ',
      'active': '–£—Ç—Ä–µ–Ω–Ω—è—è –ø—Ä–æ–±–µ–∂–∫–∞ –≤–æ–∫—Ä—É–≥ –æ–∑–µ—Ä–∞',
      'dating': '–ù–∞–ø–∏—Ç–∫–∏ –∏ —Ä–∞–∑–≥–æ–≤–æ—Ä?',
      'education': '–ì—Ä—É–ø–ø–∞ –ø–æ –∏–∑—É—á–µ–Ω–∏—é –∫ —ç–∫–∑–∞–º–µ–Ω—É –ø–æ –º–∞—Ç–µ–º–∞—Ç–∏–∫–µ',
      'animal': '–°–≤–∏–¥–∞–Ω–∏–µ —Å —Å–æ–±–∞–∫–∞–º–∏ –≤ —Å–æ–±–∞—á—å–µ–º –ø–∞—Ä–∫–µ',
      'help': '–ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å —Å –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ–º –º–µ–±–µ–ª–∏'
    },
    en: {
      'sport': 'Basketball in the park, who is with me?',
      'games': 'Mario Kart tournament at my place!',
      'art': 'Sketching session in the park',
      'social': 'Coffee and chat at Starbucks',
      'creative': 'Brainstorming new ideas for the project',
      'chill': 'Watching the sunset on the beach',
      'active': 'Morning run around the lake',
      'dating': 'Drinks and conversation?',
      'education': 'Study group for math exam',
      'animal': 'Doggy date at the dog park',
      'help': 'Need help moving furniture'
    },
    kz: {
      'sport': '–ü–∞—Ä–∫—Ç–µ –±–∞—Å–∫–µ—Ç–±–æ–ª, –∫—ñ–º –º–µ–Ω—ñ–º–µ–Ω –±—ñ—Ä–≥–µ?',
      'games': '–ú–µ–Ω—ñ“£ “Ø–π—ñ–º–¥–µ Mario Kart —Ç—É—Ä–Ω–∏—Ä—ñ!',
      'art': '–ü–∞—Ä–∫—Ç–µ —ç—Å–∫–∏–∑ —Å–∞–ª—É —Å–µ—Å—Å–∏—è—Å—ã',
      'social': 'Starbucks-—Ç–∞ –∫–æ—Ñ–µ –∂”ô–Ω–µ ”ô“£–≥—ñ–º–µ',
      'creative': '–ñ–æ–±–∞ “Ø—à—ñ–Ω –∂–∞“£–∞ –∏–¥–µ—è–ª–∞—Ä–¥—ã –±—Ä–µ–π–Ω—à—Ç–æ—Ä–º–∏–Ω–≥',
      'chill': '–ü–ª—è–∂–¥–∞ –∫“Ø–Ω –±–∞—Ç—É–¥—ã –±–∞“õ—ã–ª–∞—É',
      'active': '–¢–∞“£–µ—Ä—Ç–µ“£ –∫”©–ª –∞–π–Ω–∞–ª–∞—Å—ã–Ω–¥–∞ –∂“Ø–≥—ñ—Ä—É',
      'dating': '–°—É—Å—ã–Ω–¥–∞—Ä –∂”ô–Ω–µ ”ô“£–≥—ñ–º–µ?',
      'education': '–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞ –µ–º—Ç–∏—Ö–∞–Ω—ã–Ω–∞ –∞—Ä–Ω–∞–ª“ì–∞–Ω –æ“õ—É —Ç–æ–±—ã',
      'animal': '–ò—Ç –ø–∞—Ä–∫—ñ–Ω–¥–µ –∏—Ç—Ç–µ—Ä–º–µ–Ω –∫–µ–∑–¥–µ—Å—É',
      'help': '–ñ–∏“ª–∞–∑–¥—ã –∂—ã–ª–∂—ã—Ç—É“ì–∞ –∫”©–º–µ–∫ –∫–µ—Ä–µ–∫'
    }
  };

  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤
  const settingsDescriptions = {
    ru: {
      darkMode: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—ë–º–Ω—É—é —Ç–µ–º—É –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –±–∞—Ç–∞—Ä–µ–∏',
      showLocation: '–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –≤–∞—à—É –ª–æ–∫–∞—Ü–∏—é –Ω–∞ –∫–∞—Ä—Ç–µ',
      showDistance: '–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –≤–∞—à–µ–π –ª–æ–∫–∞—Ü–∏–∏ –¥–æ –∫–∞–∂–¥–æ–≥–æ –ø—É–ª—å—Å–∞',
      notifications: '–ü–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö –ø—É–ª—å—Å–∞—Ö —Ä—è–¥–æ–º',
      searchRadius: '–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∫–∞–∫ –¥–∞–ª–µ–∫–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø—É–ª—å—Å—ã',
      autoRefresh: '–û–±–Ω–æ–≤–ª—è—Ç—å –ø—É–ª—å—Å—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏',
      vibration: '–¢–∞–∫—Ç–∏–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å',
      pulseVisibility: '–ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ –∫—Ç–æ –º–æ–∂–µ—Ç –≤–∏–¥–µ—Ç—å –≤–∞—à–∏ –ø—É–ª—å—Å—ã',
      language: '–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è'
    },
    en: {
      darkMode: 'Use dark theme to save battery',
      showLocation: 'Show your location on the map',
      showDistance: 'Display the distance from your location to each pulse',
      notifications: 'Receive notifications about new pulses nearby',
      searchRadius: 'Set how far to show pulses',
      autoRefresh: 'Automatically refresh pulses',
      vibration: 'Tactile feedback',
      pulseVisibility: 'Control who can see your pulses',
      language: 'Choose app language'
    },
    kz: {
      darkMode: '–ë–∞—Ç–∞—Ä–µ—è–Ω—ã “Ø–Ω–µ–º–¥–µ—É “Ø—à—ñ–Ω “õ–∞—Ä–∞“£“ì—ã —Ä–µ–∂–∏–º–¥—ñ –ø–∞–π–¥–∞–ª–∞–Ω—É',
      showLocation: '–ö–∞—Ä—Ç–∞–¥–∞ —Å—ñ–∑–¥—ñ“£ –æ—Ä–Ω–∞–ª–∞—Å—É—ã“£—ã–∑–¥—ã –∫”©—Ä—Å–µ—Ç—É',
      showDistance: '–°—ñ–∑–¥—ñ“£ –æ—Ä–Ω–∞–ª–∞—Å—É—ã“£—ã–∑–¥–∞–Ω ”ô—Ä –ø—É–ª—å—Å–∫–µ –¥–µ–π—ñ–Ω–≥—ñ “õ–∞—à—ã“õ—Ç—ã“õ—Ç—ã –∫”©—Ä—Å–µ—Ç—É',
      notifications: '–ñ–∞“õ—ã–Ω –∂–µ—Ä–¥–µ–≥—ñ –∂–∞“£–∞ –ø—É–ª—å—Å—Ç–µ—Ä —Ç—É—Ä–∞–ª—ã —Ö–∞–±–∞—Ä–ª–∞–Ω–¥—ã—Ä—É–ª–∞—Ä –∞–ª—É',
      searchRadius: '–ü—É–ª—å—Å—Ç–µ—Ä–¥—ñ “õ–∞–Ω—à–∞–ª—ã“õ—Ç—ã –∞–ª—ã—Å“õ–∞ –¥–µ–π—ñ–Ω –∫”©—Ä—Å–µ—Ç—É—ñ–Ω –æ—Ä–Ω–∞—Ç—ã“£—ã–∑',
      autoRefresh: '–ü—É–ª—å—Å—Ç–µ—Ä–¥—ñ –∞–≤—Ç–æ–º–∞—Ç—Ç—ã —Ç“Ø—Ä–¥–µ –∂–∞“£–∞—Ä—Ç—É',
      vibration: '–¢–∞–∫—Ç–∏–ª—å–¥—ñ –∫–µ—Ä—ñ –±–∞–π–ª–∞–Ω—ã—Å',
      pulseVisibility: '–°—ñ–∑–¥—ñ“£ –ø—É–ª—å—Å—Ç–µ—Ä—ñ“£—ñ–∑–¥—ñ –∫—ñ–º –∫”©—Ä–µ –∞–ª–∞—Ç—ã–Ω—ã–Ω –±–∞—Å“õ–∞—Ä—É',
      language: '“ö–æ–ª–¥–∞–Ω–±–∞ —Ç—ñ–ª—ñ–Ω —Ç–∞“£–¥–∞“£—ã–∑'
    }
  };

  let currentLanguage = 'ru';

  function formatPeopleCount(count, lang) {
    const t = translations[lang];
    if (!t) return String(count);
    if (lang === 'ru') {
      if (count === 1) return `${count} ${t.peopleCount}`;
      if (count >= 2 && count <= 4) return `${count} ${t.peopleCount2}`;
      return `${count} ${t.peopleCount}`;
    }
    return `${count} ${count === 1 ? t.peopleCount : t.peopleCount2}`;
  }

  function applyLanguage(lang) {
    currentLanguage = lang;
    const t = translations[lang];
    const desc = settingsDescriptions[lang];
    const hints = categoryHints[lang];
    
    // Update UI elements
    const setTextById = (id, value) => {
      const el = document.getElementById(id);
      if (el) {
        el.textContent = value;
      }
    };
    const setTitleById = (id, value) => {
      const el = document.getElementById(id);
      if (el) {
        el.title = value;
      }
    };
    const setTextBySelector = (selector, value) => {
      const el = document.querySelector(selector);
      if (el) {
        el.textContent = value;
      }
    };
    const updateSettingEntry = (element, labelValue, descriptionValue) => {
      if (!element) return;
      let container = element.parentElement;
      while (container && !container.classList.contains('settings-item')) {
        container = container.parentElement;
      }
      if (!container) return;
      const labelEl = container.querySelector('.settings-label');
      if (labelEl) {
        labelEl.textContent = labelValue;
      }
      const descriptionEl = container.querySelector('.settings-description');
      if (descriptionEl) {
        descriptionEl.textContent = descriptionValue;
      }
    };

    setTextById('createBtn', t.createPulse);
    setTextBySelector('#createModal h3', t.createPulseTitle);
    setTextBySelector('#settingsModal h3', t.settings);
    setTextBySelector('#locationOverlay h3', t.selectLocationTitle);
    setTextBySelector('.location-instruction', t.tapToSelect);
    const confirmLocationEl = document.getElementById('confirmLocationSelect');
    if (confirmLocationEl) {
      confirmLocationEl.textContent = '‚úÖ ' + t.confirmLocation;
    }
    setTitleById('deletePulseBtn', t.deletePulse);
    setTitleById('geolocationBtn', t.returnToLocation);
    const settingsBtnEl = document.getElementById('settingsBtn');
    if (settingsBtnEl) {
      settingsBtnEl.title = t.settings;
    }
    
    // Update buttons
    setTextById('cancelCreate', t.cancel);
    setTextById('saveCreate', t.publish);
    setTextById('cancelLocationSelect', t.cancel);
    const settingsCloseBtn = document.getElementById('settingsClose');
    if (settingsCloseBtn) {
      settingsCloseBtn.setAttribute('title', t.close);
      settingsCloseBtn.setAttribute('aria-label', t.close);
    }

    if (categoryFieldLabel) categoryFieldLabel.textContent = t.categoryLabel;
    if (peopleFieldLabel) peopleFieldLabel.textContent = t.peopleLabel;
    if (categoryModalTitle) categoryModalTitle.textContent = t.categorySelectTitle;
    if (peopleModalTitle) peopleModalTitle.textContent = t.peopleSelectTitle;
    if (closeCategoryModalBtn) closeCategoryModalBtn.setAttribute('title', t.close);
    if (closePeopleModalBtn) closePeopleModalBtn.setAttribute('title', t.close);

    renderCategoryOptions();
    renderPeopleOptions();
    updateCategoryDisplay();
    updatePeopleDisplay();
    
    // Update location options (no emojis)
    const selectLocationLabelEl = document.getElementById('selectLocationLabel');
    if (selectLocationLabelEl) {
      selectLocationLabelEl.textContent = t.selectLocationLabel;
    }
    const customLocationEl = document.getElementById('customLocation');
    if (customLocationEl) {
      customLocationEl.textContent = t.chooseOnMap;
    }
    const addressLocationEl = document.getElementById('addressLocation');
    if (addressLocationEl) {
      addressLocationEl.textContent = t.writeAddress;
    }
    const addressPlaceholderEl = document.querySelector('.address-placeholder');
    if (addressPlaceholderEl) {
      addressPlaceholderEl.textContent = t.enterAddress;
    }
    const hintEl = document.querySelector('#locationMapContainer .hint');
    if (hintEl) {
      hintEl.textContent = t.locationHint;
    }
    
    // Update textarea placeholder with category-specific hint
    updateMessagePlaceholder();
    
    // Update settings labels and descriptions
    updateSettingEntry(document.getElementById('darkModeToggle'), t.darkMode, desc.darkMode);
    updateSettingEntry(document.getElementById('showLocationToggle'), t.showLocation, desc.showLocation);
    updateSettingEntry(document.getElementById('showDistanceToggle'), t.showDistance, desc.showDistance);
    updateSettingEntry(document.getElementById('notificationsToggle'), t.notifications, desc.notifications);
    const radiusSliderEl = document.getElementById('radiusSlider');
    updateSettingEntry(radiusSliderEl, t.searchRadius, desc.searchRadius);

    updateRadiusLabels();
    
    updateSettingEntry(document.getElementById('autoRefreshToggle'), t.autoRefresh, desc.autoRefresh);
    updateSettingEntry(document.getElementById('vibrationToggle'), t.vibration, desc.vibration);
    updateSettingEntry(document.getElementById('pulseVisibilityToggle'), t.pulseVisibility, desc.pulseVisibility);
    
    const languageSetting = document.getElementById('languageSetting');
    if (languageSetting) {
      const labelEl = languageSetting.querySelector('.settings-label');
      const descriptionEl = languageSetting.querySelector('.settings-description');
      if (labelEl) labelEl.textContent = t.language;
      if (descriptionEl) descriptionEl.textContent = desc.language;
    }

    // Update visibility options
    const visibilityLabels = document.querySelectorAll('.visibility-label');
    if (visibilityLabels.length >= 3) {
      visibilityLabels[0].textContent = t.public || '–ü—É–±–ª–∏—á–Ω—ã–π';
      visibilityLabels[1].textContent = t.local || '–õ–æ–∫–∞–ª—å–Ω—ã–π';
      visibilityLabels[2].textContent = t.private || '–ü—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞';
    }

    const visibilityDescriptions = document.querySelectorAll('.visibility-description');
    if (visibilityDescriptions.length >= 3) {
      visibilityDescriptions[0].textContent = t.publicDesc || '–í–∏–¥—è—Ç –≤—Å–µ –≤ —Ä–∞–¥–∏—É—Å–µ';
      visibilityDescriptions[1].textContent = t.localDesc || '–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä—è–¥–æ–º –∑–∞ 24—á';
      visibilityDescriptions[2].textContent = t.privateDesc || '–¢–æ–ª—å–∫–æ –ø–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é';
    }
    
    // Update chips
    const chips = document.querySelectorAll('.chip');
    if (chips.length > 0) {
      chips[0].textContent = t.all;
      chips[1].textContent = t.sport;
      chips[2].textContent = t.games;
      chips[3].textContent = t.art;
      chips[4].textContent = t.social;
      chips[5].textContent = t.creative;
      chips[6].textContent = t.chill;
      chips[7].textContent = t.active;
      chips[8].textContent = t.dating;
      chips[9].textContent = t.education;
      chips[10].textContent = t.animal;
      chips[11].textContent = t.help;
    }
    
    // Update language selector active state
    document.querySelectorAll('.language-option').forEach(opt => {
      opt.classList.toggle('active', opt.dataset.lang === lang);
    });
    
    // Save language preference
    localStorage.setItem('radius5_language', lang);
    
    // Re-render pulses to update time labels
    renderPulses();
    updateLocationDistanceElements();
  }

  /* -------------------- MAP OPTIMIZATION -------------------- */
  const FALLBACK = [43.238949, 76.889709]; // –ê–ª–º–∞—Ç—ã

  // Create optimized map with better tile loading
  const map = L.map('map', {
    zoomControl: false,
    attributionControl: false,
    preferCanvas: true,
    zoomSnap: 0.5,
    zoomDelta: 0.5,
    wheelPxPerZoomLevel: 60,
    fadeAnimation: true,
    markerZoomAnimation: true,
    transform3DLimit: 8388608,
    maxZoom: 19,
    minZoom: 3,
    maxBounds: [[-90, -180], [90, 180]], // Prevent panning outside world
    maxBoundsViscosity: 1.0
  }).setView(FALLBACK, 13);

  // Dark mode tile layer - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç—ë–º–Ω—ã–π —Å—Ç–∏–ª—å —á–µ—Ä–µ–∑ CartoDB Dark Matter (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π)
  const darkTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 19,
    detectRetina: false,
    updateWhenIdle: true,
    reuseTiles: true,
    updateInterval: 150,
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: 'abcd',
    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  });

  // Light mode tile layer - CartoDB Light
  const lightTileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 19,
    detectRetina: false,
    updateWhenIdle: true,
    reuseTiles: true,
    updateInterval: 150,
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: 'abcd',
    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  });

  // Ensure at least one tile layer is added on init (dark by default)
  darkTileLayer.addTo(map);

  let radiusMeters = 5000; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 5 –∫–º —Ä–∞–¥–∏—É—Å
  let center = FALLBACK;
  let locationFixed = false;

  const mask = L.circle(center, {
    radius: radiusMeters,
    color: 'rgba(0,0,0,0)',
    weight: 0,
    fillColor: 'rgba(120,160,255,0.10)',
    fillOpacity: 0.34
  }).addTo(map);

  const ring = L.circle(center, {
    radius: radiusMeters,
    color: 'rgba(120,160,255,0.75)',
    weight: 2,
    fillOpacity: 0
  }).addTo(map);

  const pulseDistanceLayer = L.layerGroup().addTo(map);
  const pulsesLayer = L.layerGroup().addTo(map);

  const meIcon = L.divIcon({
    className: '',
    html: '<div class="meDot"></div>',
    iconSize: [18, 18],
    iconAnchor: [9, 9]
  });
  let meMarker = L.marker(center, { icon: meIcon, zIndexOffset: 1000 }).addTo(map);

  /* Make sure map canvas sizes correctly after initial render */
  // Wait for DOM to be fully ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      map.whenReady(() => {
        setTimeout(() => {
          try { 
            map.invalidateSize(); 
            // Force a resize event to ensure proper rendering
            window.dispatchEvent(new Event('resize'));
          } catch (e) { 
            console.warn('Map initialization error:', e); 
          }
        }, 100);
      });
    });
  } else {
    map.whenReady(() => {
      setTimeout(() => {
        try { 
          map.invalidateSize(); 
          window.dispatchEvent(new Event('resize'));
        } catch (e) { 
          console.warn('Map initialization error:', e); 
        }
      }, 100);
    });
  }

  // Also handle window resize events
  window.addEventListener('resize', () => {
    const isTelegram = window.Telegram && window.Telegram.WebApp;
    const delay = isTelegram ? 200 : 100;
    const attempts = isTelegram ? 2 : 1;
    
    for (let i = 0; i < attempts; i++) {
      setTimeout(() => {
        try { 
          map.invalidateSize(); 
          if (locationSelectMap) {
            locationSelectMap.invalidateSize(true); // reset size
            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–ª—ã
            locationSelectMap.eachLayer((layer) => {
              if (layer instanceof L.TileLayer) {
                layer.redraw();
              }
            });
          }
        } catch (e) {
          console.warn('Resize update failed:', e);
        }
      }, delay * (i + 1));
    }
  });

  // –î–ª—è Telegram WebView —Ç–∞–∫–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
  if (window.Telegram && window.Telegram.WebApp) {
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        try {
          map.invalidateSize(true);
          if (locationSelectMap) {
            locationSelectMap.invalidateSize(true);
            locationSelectMap.eachLayer((layer) => {
              if (layer instanceof L.TileLayer) {
                layer.redraw();
              }
            });
          }
        } catch (e) {
          console.warn('Orientation change update failed:', e);
        }
      }, 500);
    });
  }

  map.on('zoomend', () => {
    refreshPulseDistanceOverlaysFromState();
  });

  /* -------------------- LOCATION SELECTION MAP -------------------- */
  let locationSelectMap;
  let selectedLocationMarker;
  let locationSelectMask;
  let locationSelectRing;
  let selectedLocation = null;
  let locationSelectDarkTiles = null;
  let locationSelectLightTiles = null;
  let locationSelectUserMarker = null;
  let locationDistanceLines = [];
  let locationDistanceLabel = null;

  const pulseDistanceOverlays = new Map();

  function initLocationSelectionMap() {
    if (locationSelectUserMarker) {
      try { locationSelectUserMarker.remove(); } catch (_) {}
      locationSelectUserMarker = null;
    }
    clearLocationDistanceLines();
    if (locationDistanceLabel) {
      try { locationDistanceLabel.remove(); } catch (_) {}
      locationDistanceLabel = null;
    }

    if (locationSelectMap) {
      locationSelectMap.remove();
    }

    if (selectedLocationMarker) {
      try {
        selectedLocationMarker.remove();
      } catch (_) {}
      selectedLocationMarker = null;
    }

    if (locationSelectMask) {
      locationSelectMask.remove();
      locationSelectMask = null;
    }

    if (locationSelectRing) {
      locationSelectRing.remove();
      locationSelectRing = null;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Telegram WebView
    const isTelegram = window.Telegram && window.Telegram.WebApp;
    
    locationSelectMap = L.map('locationSelectMap', {
      zoomControl: false,
      attributionControl: false,
      preferCanvas: true,
      maxBounds: [[-90, -180], [90, 180]],
      maxBoundsViscosity: 1.0,
      // –î–ª—è Telegram WebView –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
      zoomAnimation: !isTelegram,
      fadeAnimation: !isTelegram
    }).setView(center, 15);

    const initialLocation = state.selectedLocation ? [state.selectedLocation[0], state.selectedLocation[1]] : [center[0], center[1]];
    const circleCenter = [center[0], center[1]];

    const isDark = document.documentElement.getAttribute('data-theme') !== 'light';
    
    // Create separate tile layer instances for location selection map
    if (!locationSelectDarkTiles) {
      locationSelectDarkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        detectRetina: false,
        updateWhenIdle: !isTelegram, // –î–ª—è Telegram —Å—Ä–∞–∑—É –æ–±–Ω–æ–≤–ª—è–µ–º
        reuseTiles: true,
        updateInterval: isTelegram ? 50 : 150, // –ß–∞—â–µ –æ–±–Ω–æ–≤–ª—è–µ–º –≤ Telegram
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        // –î–ª—è Telegram –¥–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        crossOrigin: true,
        errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
      });
    }
    
    if (!locationSelectLightTiles) {
      locationSelectLightTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        detectRetina: false,
        updateWhenIdle: !isTelegram, // –î–ª—è Telegram —Å—Ä–∞–∑—É –æ–±–Ω–æ–≤–ª—è–µ–º
        reuseTiles: true,
        updateInterval: isTelegram ? 50 : 150, // –ß–∞—â–µ –æ–±–Ω–æ–≤–ª—è–µ–º –≤ Telegram
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        crossOrigin: true,
        errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
      });
    }
    
    // Use proper dark/light tiles for location selection map
    const tileLayer = isDark ? locationSelectDarkTiles : locationSelectLightTiles;
    tileLayer.addTo(locationSelectMap);
    
    // –î–ª—è Telegram WebView –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≥—Ä—É–∂–∞–µ–º —Ç–∞–π–ª—ã —Å—Ä–∞–∑—É
    if (isTelegram) {
      setTimeout(() => {
        tileLayer.redraw();
      }, 100);
    }

    locationSelectMask = L.circle(circleCenter, {
      radius: radiusMeters,
      color: 'rgba(0,0,0,0)',
      weight: 0,
      fillColor: 'rgba(120,160,255,0.10)',
      fillOpacity: 0.34
    }).addTo(locationSelectMap);

    locationSelectRing = L.circle(circleCenter, {
      radius: radiusMeters,
      color: 'rgba(120,160,255,0.75)',
      weight: 2,
      fillOpacity: 0
    }).addTo(locationSelectMap);

    const initialLatLng = clampToRadius(L.latLng(initialLocation[0], initialLocation[1]));

    selectedLocationMarker = L.marker(initialLatLng, {
      draggable: true,
      icon: L.divIcon({
        className: 'leaflet-div-icon location-marker-icon',
        html: '<div class="location-marker"></div>',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
      })
    }).addTo(locationSelectMap);

    selectedLocation = [initialLatLng.lat, initialLatLng.lng];

    updateLocationSelectionShapes();
    updateLocationDistanceElements();

    locationSelectMap.on('click', (e) => {
      const clamped = clampToRadius(e.latlng);
      selectedLocationMarker.setLatLng(clamped);
      selectedLocation = [clamped.lat, clamped.lng];
      updateLocationDistanceElements();
    });

    selectedLocationMarker.on('drag', (e) => {
      const marker = e.target;
      const position = marker.getLatLng();
      const clamped = clampToRadius(position);
      if (!clamped.equals(position)) {
        marker.setLatLng(clamped);
      }
      const current = marker.getLatLng();
      selectedLocation = [current.lat, current.lng];
      updateLocationDistanceElements();
    });

    selectedLocationMarker.on('dragend', (e) => {
      const marker = e.target;
      const position = marker.getLatLng();
      const clamped = clampToRadius(position);
      marker.setLatLng(clamped);
      selectedLocation = [clamped.lat, clamped.lng];
      updateLocationDistanceElements();
    });

    // –î–ª—è Telegram WebView –¥–µ–ª–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ—Ä–∞—Å—á–µ—Ç–∞ —Ä–∞–∑–º–µ—Ä–∞
    const invalidateSizeAttempts = isTelegram ? 5 : 1;
    const delay = isTelegram ? 200 : 120;
    
    for (let i = 0; i < invalidateSizeAttempts; i++) {
      setTimeout(() => {
        requestAnimationFrame(() => {
          try { 
            locationSelectMap.invalidateSize(i === 0); // reset —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –ø–æ–ø—ã—Ç–∫–µ
            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–ª—ã
            locationSelectMap.eachLayer((layer) => {
              if (layer instanceof L.TileLayer) {
                layer.redraw();
              }
            });
            // –ù–µ–±–æ–ª—å—à–æ–π –ø–∞–Ω –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏ (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –ø–æ–ø—ã—Ç–∫–µ)
            if (i === 0 && isTelegram) {
              setTimeout(() => {
                locationSelectMap.panBy([1, 0], { animate: false });
                setTimeout(() => {
                  locationSelectMap.panBy([-1, 0], { animate: false });
                }, 100);
              }, 50);
            }
          } catch (e) { 
            console.warn('Location map invalidateSize attempt', i + 1, 'failed:', e);
          }
        });
      }, delay * (i + 1));
    }
  }

  function updateLocationSelectionShapes() {
    const circleCenter = [center[0], center[1]];
    if (locationSelectMask) {
      locationSelectMask.setLatLng(circleCenter);
      locationSelectMask.setRadius(radiusMeters);
    }
    if (locationSelectRing) {
      locationSelectRing.setLatLng(circleCenter);
      locationSelectRing.setRadius(radiusMeters);
    }
  }

  function formatDistanceDisplay(distance) {
    if (!Number.isFinite(distance)) return '';
    const localeMap = { ru: 'ru-RU', en: 'en-US', kz: 'kk-KZ' };
    const locale = localeMap[currentLanguage] || 'en-US';
    const t = translations[currentLanguage] || translations.ru;

    if (distance >= 1000) {
      const kmValue = distance / 1000;
      const precision = kmValue >= 10 ? 0 : 1;
      const formatted = kmValue.toLocaleString(locale, {
        minimumFractionDigits: precision,
        maximumFractionDigits: precision
      });
      const unit = t.distanceKmLabel || t.distanceUnit || 'km';
      return `${formatted} ${unit}`;
    }

    const rounded = distance >= 100 ? Math.round(distance / 10) * 10 : Math.round(distance);
    const formatted = rounded.toLocaleString(locale);
    const unit = t.distanceMetersLabel || 'm';
    return `${formatted} ${unit}`;
  }

  const DISTANCE_LABEL_CHAR_WIDTH_PX = 7;
  const DISTANCE_LABEL_PADDING_PX = 24;
  const DISTANCE_LABEL_MIN_GAP_PX = 40;

  function calculateDistanceOverlayData(mapInstance, startLatLng, endLatLng) {
    if (!mapInstance || !startLatLng || !endLatLng) return null;
    const toLeafletLatLng = (value) => {
      if (!value) return null;
      const lat = typeof value.lat === 'number' ? value.lat : Array.isArray(value) ? value[0] : null;
      const lng = typeof value.lng === 'number' ? value.lng : Array.isArray(value) ? value[1] : null;
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
      return L.latLng(lat, lng);
    };

    const fromLL = toLeafletLatLng(startLatLng);
    const toLL = toLeafletLatLng(endLatLng);
    if (!fromLL || !toLL) return null;

    let currentZoom = null;
    try {
      currentZoom = mapInstance.getZoom?.();
    } catch (_) {
      currentZoom = null;
    }
    if (!Number.isFinite(currentZoom)) {
      try {
        currentZoom = mapInstance.getZoom();
      } catch (_) {
        currentZoom = 13;
      }
    }
    if (!Number.isFinite(currentZoom)) {
      currentZoom = 13;
    }

    let pointA;
    let pointB;
    try {
      pointA = mapInstance.project(fromLL, currentZoom);
      pointB = mapInstance.project(toLL, currentZoom);
    } catch (e) {
      console.warn('Distance overlay projection failed', e);
      return null;
    }

    const diff = pointB.subtract(pointA);
    const lengthPx = Math.hypot(diff.x, diff.y);
    if (!Number.isFinite(lengthPx) || lengthPx < 1) {
      return {
        segments: [],
        midpoint: fromLL,
        angleDeg: 0,
        formatted: formatDistanceDisplay(distanceMeters(fromLL.lat, fromLL.lng, toLL.lat, toLL.lng)),
        distance: distanceMeters(fromLL.lat, fromLL.lng, toLL.lat, toLL.lng)
      };
    }

    const midpointPx = pointA.add(diff.multiplyBy(0.5));
    const midpoint = mapInstance.unproject(midpointPx, currentZoom);

    const distance = distanceMeters(fromLL.lat, fromLL.lng, toLL.lat, toLL.lng);
    const formatted = formatDistanceDisplay(distance);

    const estimatedGap = formatted.length
      ? (formatted.length * DISTANCE_LABEL_CHAR_WIDTH_PX) + DISTANCE_LABEL_PADDING_PX
      : DISTANCE_LABEL_MIN_GAP_PX;
    const maxGap = Math.max(0, lengthPx - 6);
    const targetGap = Math.max(0, Math.min(maxGap, Math.max(DISTANCE_LABEL_MIN_GAP_PX, estimatedGap)));

    let segments;
    if (targetGap > 0 && lengthPx > targetGap + 6) {
      const unit = diff.multiplyBy(1 / Math.max(lengthPx, 1));
      const halfGap = targetGap / 2;
      const gapVector = unit.multiplyBy(halfGap);
      const startGapPx = midpointPx.subtract(gapVector);
      const endGapPx = midpointPx.add(gapVector);
      const startGapLatLng = mapInstance.unproject(startGapPx, currentZoom);
      const endGapLatLng = mapInstance.unproject(endGapPx, currentZoom);
      segments = [
        [fromLL, startGapLatLng],
        [endGapLatLng, toLL]
      ];
    } else {
      segments = [[fromLL, toLL]];
    }

    const angleRad = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x);
    let angleDeg = angleRad * 180 / Math.PI;
    const normalized = ((angleDeg % 360) + 360) % 360;
    if (normalized > 90 && normalized < 270) {
      angleDeg -= 180;
    }

    return {
      segments,
      midpoint,
      angleDeg,
      formatted,
      distance
    };
  }

  function createDistanceLabelIcon(text, angleDeg) {
    const safe = typeof text === 'string' ? text : String(text ?? '');
    const escaped = safe.replace(/[&<>"']/g, (char) => {
      switch (char) {
        case '&': return '&amp;';
        case '<': return '&lt;';
        case '>': return '&gt;';
        case '"': return '&quot;';
        case "'": return '&#39;';
        default: return char;
      }
    });
    const angleValue = Number.isFinite(angleDeg) ? `${angleDeg}deg` : '0deg';
    return L.divIcon({
      className: 'leaflet-div-icon location-distance-label',
      html: `<div class="distance-text" style="--angle:${angleValue};">${escaped}</div>`,
      iconSize: [0, 0]
    });
  }

  function updateLocationDistanceElements() {
    if (!locationSelectMap) return;

    const hasMe = state && state.me && Number.isFinite(state.me.lat) && Number.isFinite(state.me.lng);
    const meLatLng = hasMe ? L.latLng(state.me.lat, state.me.lng) : null;

    if (!meLatLng) {
      if (locationSelectUserMarker) {
        try { locationSelectUserMarker.remove(); } catch (_) {}
        locationSelectUserMarker = null;
      }
      clearLocationDistanceLines();
      if (locationDistanceLabel) {
        try { locationDistanceLabel.remove(); } catch (_) {}
        locationDistanceLabel = null;
      }
      return;
    }

    if (!locationSelectUserMarker) {
      locationSelectUserMarker = L.marker(meLatLng, {
        interactive: false,
        zIndexOffset: 900,
        icon: L.divIcon({
          className: 'leaflet-div-icon me-dot-marker',
          html: '<div class="meDot"></div>',
          iconSize: [18, 18],
          iconAnchor: [9, 9]
        })
      }).addTo(locationSelectMap);
    } else {
      locationSelectUserMarker.setLatLng(meLatLng);
    }

    const selectedLatLng = selectedLocationMarker
      ? selectedLocationMarker.getLatLng()
      : (Array.isArray(selectedLocation) && selectedLocation.length === 2
        ? L.latLng(selectedLocation[0], selectedLocation[1])
        : null);

    if (!selectedLatLng) {
      clearLocationDistanceLines();
      if (locationDistanceLabel) {
        try { locationDistanceLabel.remove(); } catch (_) {}
        locationDistanceLabel = null;
      }
      return;
    }

    const overlayData = calculateDistanceOverlayData(locationSelectMap, meLatLng, selectedLatLng);
    if (!overlayData || !overlayData.segments || overlayData.segments.length === 0) {
      clearLocationDistanceLines();
      if (locationDistanceLabel) {
        try { locationDistanceLabel.remove(); } catch (_) {}
        locationDistanceLabel = null;
      }
      return;
    }

    const { segments, midpoint, angleDeg, formatted } = overlayData;

    const lineStyle = {
      color: 'rgba(255, 100, 100, 0.6)',
      weight: 4,
      opacity: 0.85,
      lineCap: 'round',
      lineJoin: 'round',
      interactive: false
    };

    if (locationDistanceLines.length !== segments.length) {
      clearLocationDistanceLines();
      segments.forEach(seg => {
        const line = L.polyline(seg, lineStyle).addTo(locationSelectMap);
        locationDistanceLines.push(line);
      });
    } else {
      segments.forEach((seg, idx) => {
        locationDistanceLines[idx].setLatLngs(seg);
      });
    }

    if (!locationDistanceLabel) {
      locationDistanceLabel = L.marker(midpoint, {
        interactive: false,
        icon: createDistanceLabelIcon(formatted, angleDeg),
        zIndexOffset: 950
      }).addTo(locationSelectMap);
    } else {
      locationDistanceLabel.setLatLng(midpoint);
      locationDistanceLabel.setIcon(createDistanceLabelIcon(formatted, angleDeg));
    }
  }

  function normalizeLatLngInput(value) {
    if (!value) return null;
    if (value instanceof L.LatLng) return value;
    if (Array.isArray(value) && value.length >= 2) {
      const [lat, lng] = value;
      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        return L.latLng(lat, lng);
      }
      return null;
    }
    const lat = Number(value.lat);
    const lng = Number(value.lng);
    if (Number.isFinite(lat) && Number.isFinite(lng)) {
      return L.latLng(lat, lng);
    }
    return null;
  }

  function removePulseDistanceOverlay(pulseId) {
    if (!pulseDistanceOverlays.has(pulseId)) return;
    const overlay = pulseDistanceOverlays.get(pulseId);
    if (overlay && Array.isArray(overlay.lines)) {
      overlay.lines.forEach(line => {
        try { line.remove(); } catch (_) {}
      });
    }
    if (overlay && overlay.label) {
      try { overlay.label.remove(); } catch (_) {}
    }
    pulseDistanceOverlays.delete(pulseId);
  }

  function clearPulseDistanceOverlays() {
    const ids = Array.from(pulseDistanceOverlays.keys());
    ids.forEach(id => removePulseDistanceOverlay(id));
    try {
      pulseDistanceLayer.clearLayers();
    } catch (_) {}
    pulseDistanceOverlays.clear();
  }

  function updatePulseDistanceOverlay(pulseId, targetLatLngInput) {
    if (!settings.showDistance || !settings.showLocation) {
      removePulseDistanceOverlay(pulseId);
      return;
    }

    if (!state || !state.hasLocation || !state.me || !Number.isFinite(state.me.lat) || !Number.isFinite(state.me.lng)) {
      clearPulseDistanceOverlays();
      return;
    }

    const meLatLng = L.latLng(state.me.lat, state.me.lng);
    let targetLatLng = normalizeLatLngInput(targetLatLngInput);
    const existing = pulseDistanceOverlays.get(pulseId);
    if (!targetLatLng && existing && existing.targetLatLng) {
      targetLatLng = normalizeLatLngInput(existing.targetLatLng);
    }
    if (!targetLatLng) {
      removePulseDistanceOverlay(pulseId);
      return;
    }

    const overlayData = calculateDistanceOverlayData(map, meLatLng, targetLatLng);
    if (!overlayData || !overlayData.segments || overlayData.segments.length === 0) {
      removePulseDistanceOverlay(pulseId);
      return;
    }

    const lineStyle = {
      color: 'rgba(255, 100, 100, 0.6)',
      weight: 4,
      opacity: 0.85,
      lineCap: 'round',
      lineJoin: 'round',
      interactive: false
    };

    if (!existing) {
      const lines = overlayData.segments.map(seg => {
        const line = L.polyline(seg, lineStyle).addTo(pulseDistanceLayer);
        if (typeof line.bringToBack === 'function') {
          line.bringToBack();
        }
        return line;
      });
      const label = L.marker(overlayData.midpoint, {
        interactive: false,
        icon: createDistanceLabelIcon(overlayData.formatted, overlayData.angleDeg),
        zIndexOffset: 950
      }).addTo(pulseDistanceLayer);
      pulseDistanceOverlays.set(pulseId, {
        lines,
        label,
        targetLatLng
      });
      return;
    }

    const hasMatchingSegments = Array.isArray(existing.lines) && existing.lines.length === overlayData.segments.length;
    if (!hasMatchingSegments) {
      removePulseDistanceOverlay(pulseId);
      updatePulseDistanceOverlay(pulseId, targetLatLng);
      return;
    }

    existing.targetLatLng = targetLatLng;
    existing.lines.forEach((line, idx) => {
      try {
        line.setLatLngs(overlayData.segments[idx]);
      } catch (e) {
        console.warn('Failed to update distance line', e);
      }
    });
    if (existing.label) {
      existing.label.setLatLng(overlayData.midpoint);
      existing.label.setIcon(createDistanceLabelIcon(overlayData.formatted, overlayData.angleDeg));
    } else {
      existing.label = L.marker(overlayData.midpoint, {
        interactive: false,
        icon: createDistanceLabelIcon(overlayData.formatted, overlayData.angleDeg),
        zIndexOffset: 950
      }).addTo(pulseDistanceLayer);
    }
  }

  function updatePulseDistanceOverlaysForVisible(visiblePulses) {
    if (!settings.showDistance || !settings.showLocation) {
      clearPulseDistanceOverlays();
      return;
    }

    if (!Array.isArray(visiblePulses)) {
      visiblePulses = [];
    }

    const hasLocation = state && state.hasLocation && state.me && Number.isFinite(state.me.lat) && Number.isFinite(state.me.lng);
    if (!hasLocation) {
      clearPulseDistanceOverlays();
      return;
    }

    const activeIds = new Set();
    visiblePulses.forEach(entry => {
      if (!entry) return;
      const { id, row } = entry;
      if (!id || !row) return;
      const lat = Number(row.lat);
      const lng = Number(row.lng);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
        removePulseDistanceOverlay(id);
        return;
      }
      updatePulseDistanceOverlay(id, L.latLng(lat, lng));
      activeIds.add(id);
    });

    const existingIds = Array.from(pulseDistanceOverlays.keys());
    existingIds.forEach(id => {
      if (!activeIds.has(id)) {
        removePulseDistanceOverlay(id);
      }
    });
  }

  function refreshPulseDistanceOverlaysFromState() {
    if (!settings.showDistance || !settings.showLocation) {
      clearPulseDistanceOverlays();
      return;
    }
    if (!pulseDistanceOverlays.size) return;
    if (!state || !state.hasLocation || !state.me || !Number.isFinite(state.me.lat) || !Number.isFinite(state.me.lng)) {
      clearPulseDistanceOverlays();
      return;
    }
    const ids = Array.from(pulseDistanceOverlays.keys());
    ids.forEach(id => updatePulseDistanceOverlay(id));
  }

  function clampToRadius(latlng) {
    if (!locationSelectMap) return latlng;

    if (!latlng) {
      return L.latLng(center[0], center[1]);
    }

    const circleCenter = L.latLng(center[0], center[1]);
    const candidate = (typeof latlng.lat === 'number' && typeof latlng.lng === 'number')
      ? L.latLng(latlng.lat, latlng.lng)
      : Array.isArray(latlng)
        ? L.latLng(latlng[0], latlng[1])
        : circleCenter;

    const distance = locationSelectMap.distance(circleCenter, candidate);
    if (!isFinite(distance) || distance <= radiusMeters || radiusMeters <= 0) {
      return candidate;
    }

    const centerPoint = locationSelectMap.project(circleCenter);
    const targetPoint = locationSelectMap.project(candidate);
    const direction = targetPoint.subtract(centerPoint);

    if (!direction.x && !direction.y) {
      return circleCenter;
    }

    const scale = radiusMeters / distance;
    const clampedPoint = centerPoint.add(direction.multiplyBy(scale));
    return locationSelectMap.unproject(clampedPoint);
  }

  /* -------------------- SETTINGS STATE -------------------- */
  const settings = {
    darkMode: true,
    showLocation: true,
    showDistance: false,
    notifications: true,
    searchRadius: 5,
    autoRefresh: false,
    vibration: true,
    pulseVisibility: false,
    visibilityMode: 'public',
    language: 'ru'
  };

  /* -------------------- THEME MANAGEMENT -------------------- */
  function applyTheme(isDark) {
    const root = document.documentElement;
    if (isDark) {
      root.setAttribute('data-theme', 'dark');
      // Switch to dark tiles properly
      try {
        if (map.hasLayer(lightTileLayer)) map.removeLayer(lightTileLayer);
      } catch (e) {}
      if (!map.hasLayer(darkTileLayer)) darkTileLayer.addTo(map);
      // update locationSelectMap tiles if present
      if (locationSelectMap) {
        locationSelectMap.eachLayer((layer) => {
          if (layer instanceof L.TileLayer) locationSelectMap.removeLayer(layer);
        });
        // Use the separate tile layer instance for location selection map
        if (locationSelectDarkTiles) {
          locationSelectDarkTiles.addTo(locationSelectMap);
        } else {
          locationSelectDarkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { 
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd'
          });
          locationSelectDarkTiles.addTo(locationSelectMap);
        }
        setTimeout(() => { try { locationSelectMap.invalidateSize(); } catch(e){} }, 100);
      }
    } else {
      root.setAttribute('data-theme', 'light');
      // Switch to light tiles properly
      try {
        if (map.hasLayer(darkTileLayer)) map.removeLayer(darkTileLayer);
      } catch (e) {}
      if (!map.hasLayer(lightTileLayer)) lightTileLayer.addTo(map);
      if (locationSelectMap) {
        locationSelectMap.eachLayer((layer) => {
          if (layer instanceof L.TileLayer) locationSelectMap.removeLayer(layer);
        });
        // Use the separate tile layer instance for location selection map
        if (locationSelectLightTiles) {
          locationSelectLightTiles.addTo(locationSelectMap);
        } else {
          locationSelectLightTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { 
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd'
          });
          locationSelectLightTiles.addTo(locationSelectMap);
        }
        setTimeout(() => { try { locationSelectMap.invalidateSize(); } catch(e){} }, 100);
      }
    }

    // After changing tile layers, invalidate size so tiles render correctly in WebViews
    setTimeout(() => {
      try { map.invalidateSize(); } catch (e) { console.warn('invalidateSize failed', e); }
      // also force a small pan to trigger tile redraw on some engines
      try { map.panBy([0.0001, 0.0001], {animate:false}); } catch(e){}
    }, 120);

    // Ensure mask/ring radiuses match settings if changed
    mask.setRadius(radiusMeters);
    ring.setRadius(radiusMeters);
  }

  /* -------------------- UI: chips -------------------- */
  const categories = [
    { id: 'all', label: '–í—Å–µ' },
    { id: 'sport', label: '–°–ø–æ—Ä—Ç' },
    { id: 'games', label: '–ò–≥—Ä—ã' },
    { id: 'art', label: '–ò—Å–∫—É—Å—Å—Ç–≤–æ' },
    { id: 'social', label: '–°–æ—Ü–∏–∞–ª—å–Ω–æ–µ' },
    { id: 'creative', label: '–ö—Ä–µ–∞—Ç–∏–≤' },
    { id: 'chill', label: '–û—Ç–¥—ã—Ö' },
    { id: 'active', label: '–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å' },
    { id: 'dating', label: '–ó–Ω–∞–∫–æ–º—Å—Ç–≤–∞' },
    { id: 'education', label: '–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ' },
    { id: 'animal', label: '–ñ–∏–≤–æ—Ç–Ω—ã–µ' },
    { id: 'help', label: '–ü–æ–º–æ—â—å' }
  ];

  const chips = document.getElementById('chips');
  categories.forEach((c, i) => {
    const el = document.createElement('button');
    el.className = 'chip' + (i === 0 ? ' active' : '');
    el.dataset.cat = c.id;
    el.textContent = c.label;
    el.onclick = () => {
      document.querySelectorAll('.chip').forEach(ch => ch.classList.remove('active'));
      el.classList.add('active');
      renderPulses();
    };
    chips.appendChild(el);
  });

  function activeCat() {
    const el = document.querySelector('.chip.active');
    return el ? el.dataset.cat : 'all';
  }

  /* -------------------- DATA MODEL -------------------- */
  const state = {
    pulses: new Map(),
    me: { lat: center[0], lng: center[1] },
    customLocation: null,
    selectedLocation: null,
    myPulses: new Set(), // Track user's own pulses
    selectedPulseId: null, // Track currently selected pulse for deletion
    hasLocation: false
  };

  function getEmojiForCategory(cat) {
    const emojis = {
      'sport': 'üèÉ',
      'games': 'üéÆ',
      'art': 'üé®',
      'social': 'üë•',
      'creative': 'üí°',
      'chill': 'üòå',
      'active': '‚ö°',
      'dating': 'üíï',
      'education': 'üìö',
      'animal': 'üêï',
      'help': 'ü§ù'
    };
    return emojis[cat] || 'üìç';
  }

  // –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
  function getPulseStyle(createdAt) {
    const now = new Date();
    const created = new Date(createdAt);
    const diffMs = now - created;
    const diffMins = Math.floor(diffMs / 60000);
    
    if (diffMins < 30) {
      return { colorClass: 'pulse-green', animationClass: 'ring-fast' };
    } else if (diffMins < 60) {
      return { colorClass: 'pulse-orange', animationClass: 'ring-medium' };
    } else {
      return { colorClass: 'pulse-red', animationClass: 'ring-slow' };
    }
  }

  /* Distance util (meters) */
  function distanceMeters(lat1, lng1, lat2, lng2) {
    const R = 6378137;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  function withinRadius(lat, lng) {
    return distanceMeters(center[0], center[1], lat, lng) <= radiusMeters;
  }

  /* -------------------- RENDER -------------------- */
  function formatTimeAgo(createdAt) {
    const now = new Date();
    const created = new Date(createdAt);
    const diffMs = now - created;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);

    const t = translations[currentLanguage];
    
    if (diffMins < 1) return t.justNow;
    if (diffMins < 60) return `${diffMins}${t.minutesAgo}`;
    if (diffHours < 24) return `${diffHours}${t.hoursAgo}`;
    return `${Math.floor(diffHours / 24)}${t.daysAgo}`;
  }

  function ensureTooltipWithinView(marker) {
    if (!marker || !marker.getTooltip) return;
    const tooltip = marker.getTooltip();
    if (!tooltip) return;

    const container = typeof tooltip.getElement === 'function' ? tooltip.getElement() : tooltip._container;
    if (!container) return;

    const mapContainer = map.getContainer();
    const mapRect = mapContainer.getBoundingClientRect();
    const tooltipRect = container.getBoundingClientRect();
    const padding = 20;

    let dx = 0;
    if (tooltipRect.left < mapRect.left + padding) {
      dx = tooltipRect.left - (mapRect.left + padding);
    } else if (tooltipRect.right > mapRect.right - padding) {
      dx = tooltipRect.right - (mapRect.right - padding);
    }

    let dy = 0;
    if (tooltipRect.top < mapRect.top + padding) {
      dy = tooltipRect.top - (mapRect.top + padding);
    } else if (tooltipRect.bottom > mapRect.bottom - padding) {
      dy = tooltipRect.bottom - (mapRect.bottom - padding);
    }

    if (dx !== 0 || dy !== 0) {
      map.panBy([-dx, -dy], { animate: true, duration: 0.3, easeLinearity: 0.25 });
    }
  }

  function focusPulse(marker) {
    if (!marker) return;

    const latlng = marker.getLatLng();
    const currentCenter = map.getCenter();
    const currentZoom = map.getZoom();
    const needsPan = currentCenter && currentCenter.distanceTo ? currentCenter.distanceTo(latlng) > 1 : true;

    let hasOpened = false;
    const openAndAdjust = () => {
      if (hasOpened) return;
      hasOpened = true;
      marker.openTooltip();
      requestAnimationFrame(() => {
        ensureTooltipWithinView(marker);
        setTimeout(() => ensureTooltipWithinView(marker), 160);
      });
    };

    if (needsPan) {
      map.once('moveend', openAndAdjust);
      map.flyTo(latlng, currentZoom, { animate: true, duration: 0.6, easeLinearity: 0.25 });
      setTimeout(openAndAdjust, 650);
    } else {
      openAndAdjust();
    }
  }

  function makeMarker(row) {
    const emoji = getEmojiForCategory(row.category);
    const pulseStyle = getPulseStyle(row.created_at);
    
    const iconHtml = `<div class="pulse ${pulseStyle.colorClass}">
        <div class="ring ${pulseStyle.animationClass}"></div><span>${emoji}</span>
      </div>`;
      
    const icon = L.divIcon({ className: '', html: iconHtml, iconSize: [52, 52], iconAnchor: [26, 26] });
    const m = L.marker([row.lat, row.lng], { icon }).addTo(pulsesLayer);

    const timeAgo = formatTimeAgo(row.created_at);
    const t = translations[currentLanguage];
    const isMyPulse = state.myPulses.has(row.id);
    
    let buttonsHtml = '';
    if (isMyPulse) {
      buttonsHtml = `<button type="button" class="delete-btn" onclick="deletePulse('${row.id}')">${escapeHtml(t.delete)}</button>`;
    } else {
      buttonsHtml = `<button type="button" class="join-btn" onclick="joinPulse('${row.id}')">${escapeHtml(t.join)}</button>`;
    }

    const categoryLabel = row.category ? (t[row.category] || (categories.find(c => c.id === row.category)?.label) || row.category) : '';
    const tooltipParts = [
      '<div class="pulse-label-content">',
      `<div class="pulse-message">${escapeHtml(row.message || '')}</div>`
    ];

    if (categoryLabel) {
      tooltipParts.push(`<div class="pulse-category">${escapeHtml(categoryLabel)}</div>`);
    }

    if (isMyPulse && t.yourPulse) {
      tooltipParts.push(`<div class="pulse-tag">${escapeHtml(t.yourPulse)}</div>`);
    }

    tooltipParts.push(`<div class="pulse-time">${timeAgo}</div>`);
    tooltipParts.push(buttonsHtml);
    tooltipParts.push('</div>');

    const tooltipHtml = tooltipParts.join('');

    m.bindTooltip(
      tooltipHtml,
      { className: 'pulse-label', direction: 'bottom', offset: [0, 28], opacity: 1, permanent: false, interactive: true }
    );
    
    m.on('click', () => {
      focusPulse(m);
      // Show delete button if this is user's pulse
      if (isMyPulse) {
        state.selectedPulseId = row.id;
        document.getElementById('deletePulseBtn').style.display = 'grid';
      } else {
        state.selectedPulseId = null;
        document.getElementById('deletePulseBtn').style.display = 'none';
      }
    });
    
    return m;
  }

  // –£–ü–†–û–©–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –ø—É–ª—å—Å–∞
  async function deletePulse(pulseId) {
    const t = translations[currentLanguage];
    if (confirm(t.deleteConfirm)) {
      const { error } = await db
        .from('pulses')
        .update({ status: 'deleted' })
        .eq('id', pulseId);

      if (error) {
        const message = (error && error.message) || t.errorUnknown;
        alert(`${t.deleteError}: ${message}`);
        return;
      }

      state.pulses.delete(pulseId);
      state.myPulses.delete(pulseId);
      if (state.selectedPulseId === pulseId) {
        state.selectedPulseId = null;
        document.getElementById('deletePulseBtn').style.display = 'none';
      }
      renderPulses();
      
      if (settings.vibration && navigator.vibrate) {
        navigator.vibrate(50);
      }
    }
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø—É–ª—å—Å–∞ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É
  async function deleteSelectedPulse() {
    if (!state.selectedPulseId) return;
    await deletePulse(state.selectedPulseId);
  }

  function joinPulse(pulseId) {
    const pulse = state.pulses.get(pulseId);
    if (pulse) {
      const pulseData = pulse.row;
      const t = translations[currentLanguage];
      const template = t.joinPreview || `üéâ {join}!\n\n"{message}"\n\nIn the real app this would open a chat with the creator!`;
      const previewMessage = template
        .replace('{join}', t.join)
        .replace('{message}', pulseData.message || '');
      alert(previewMessage);

      if (pulse.marker) {
        pulse.marker.closeTooltip();
      }
    }
  }

  function renderPulses() {
    pulsesLayer.clearLayers();
    const cat = activeCat();
    const now = Date.now();
    const visiblePulses = [];
    for (const [id, entry] of state.pulses) {
      const r = entry.row;
      if (r.status !== 'active') continue;
      if (r.expires_at && new Date(r.expires_at).getTime() < now) continue;
      if (cat !== 'all' && r.category !== cat) continue;
      if (!withinRadius(r.lat, r.lng)) continue;
      entry.marker = makeMarker(r);
      visiblePulses.push({ id, row: r });
    }
    updatePulseDistanceOverlaysForVisible(visiblePulses);
  }

  /* -------------------- GEO - –ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ï –û–¢–°–õ–ï–ñ–ò–í–ê–ù–ò–ï –õ–û–ö–ê–¶–ò–ò -------------------- */
  let watchId = null;
  let lastReportedPos = null;
  let permissionState = 'unknown';
  let hasInitialCentered = false; // –§–ª–∞–≥ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏

  /* Move center circle and marker only if locationFixed is false and moved more than threshold */
  function moveCircle(lat, lng) {
    if (locationFixed) return;

    // Only update if moved a reasonable distance to avoid jitter
    if (lastReportedPos) {
      const dist = distanceMeters(lastReportedPos.lat, lastReportedPos.lng, lat, lng);
      if (dist < 25) return; // ignore tiny movements under 25 meters
    }

    center = [lat, lng];
    mask.setLatLng(center); 
    ring.setLatLng(center);
    meMarker.setLatLng(center);
    state.me = { lat: lat, lng: lng };
    state.hasLocation = true;
    lastReportedPos = { lat, lng };
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç—É –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –ø–æ–ª—É—á–µ–Ω–∏–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏
    if (!hasInitialCentered) {
      map.setView([lat, lng], 14, { animate: true, duration: 1 });
      hasInitialCentered = true;
    }
    
    updateLocationSelectionShapes();
    if (selectedLocationMarker) {
      const clamped = clampToRadius(selectedLocationMarker.getLatLng());
      selectedLocationMarker.setLatLng(clamped);
      selectedLocation = [clamped.lat, clamped.lng];
    }
    renderPulses();
    updateLocationDistanceElements();
  }

  function fixLocation(lat, lng) {
    locationFixed = true;
    center = [lat, lng];
    mask.setLatLng(center);
    ring.setLatLng(center);
    meMarker.setLatLng(center);
    state.me = { lat: lat, lng: lng };
    state.hasLocation = true;
    map.setView([lat, lng], 14);
    updateLocationSelectionShapes();
    if (selectedLocationMarker) {
      const clamped = clampToRadius(selectedLocationMarker.getLatLng());
      selectedLocationMarker.setLatLng(clamped);
      selectedLocation = [clamped.lat, clamped.lng];
    }
    renderPulses();
    updateLocationDistanceElements();
  }

  // Improved location tracking:
  // - Use Permissions API to avoid re-requesting permission repeatedly
  // - Keep a single watchPosition (don't call getCurrentPosition repeatedly)
  // - Pause requesting when user denies
  async function startLocationTracking() {
    if (!('geolocation' in navigator)) {
      console.log('Geolocation not available');
      return;
    }

    // If watch already active, do not re-create it (prevents repeated prompts)
    if (watchId) {
      return;
    }

    // Query permission state if available
    try {
      if (navigator.permissions && navigator.permissions.query) {
        const perm = await navigator.permissions.query({ name: 'geolocation' });
        permissionState = perm.state;
        perm.onchange = () => {
          permissionState = perm.state;
        };
      }
    } catch (e) {
      console.log('Permissions API unavailable', e);
    }

    // If permission is 'denied', don't attempt to ask again automatically
    if (permissionState === 'denied') {
      console.log('Geolocation permission denied; not requesting.');
      return;
    }

    // Request initial position once only if we don't have lastReportedPos
    // We avoid calling getCurrentPosition repeatedly (it may re-trigger prompts on some platforms)
    if (!lastReportedPos) {
      try {
        navigator.geolocation.getCurrentPosition(pos => {
          const { latitude, longitude } = pos.coords;
          // Do not call fixLocation here if we want continuous updates and avoid repeated center resets.
          // Use moveCircle to set initial and keep tracking.
          moveCircle(latitude, longitude);
        }, err => {
          console.log('Initial getCurrentPosition failed', err);
        }, { enableHighAccuracy: true, timeout: 15000 });
      } catch (e) {
        console.log('getCurrentPosition failed', e);
      }
    }

    // Start watchPosition once (this will not prompt on many platforms if permission already granted)
    try {
      watchId = navigator.geolocation.watchPosition(
        pos => {
          const { latitude, longitude, accuracy } = pos.coords;
          // Only use updates with acceptable accuracy
          if (typeof accuracy === 'number' && accuracy > 150) {
            // too inaccurate, skip
            return;
          }
          // Update only if moved sufficiently (this prevents small background jiggling)
          if (!lastReportedPos) {
            moveCircle(latitude, longitude);
          } else {
            const moved = distanceMeters(lastReportedPos.lat, lastReportedPos.lng, latitude, longitude);
            // update when user moved > ~30-50 meters or when accuracy improves
            if (moved > 30 || (accuracy && accuracy < 50)) {
              moveCircle(latitude, longitude);
            }
          }
        },
        error => {
          console.log('Location tracking error:', error);
          // if permission denied, mark state and clear watch to avoid repeated prompts
          if (error && error.code === 1) {
            permissionState = 'denied';
            if (watchId) {
              navigator.geolocation.clearWatch(watchId);
              watchId = null;
            }
          }
        },
        {
          enableHighAccuracy: true,
          maximumAge: 5000, // accept cached positions up to 5s
          timeout: 27000
        }
      );
    } catch (e) {
      console.log('watchPosition creation failed', e);
    }
  }

  // Stop tracking (used when user toggles showLocation off)
  function stopLocationTracking() {
    if (watchId) {
      try {
        navigator.geolocation.clearWatch(watchId);
      } catch (e) { /* ignore */ }
      watchId = null;
    }
  }

  /* Start tracking on load if setting allows */
  startLocationTracking();

  /* Also respect visibility change: do NOT re-request permission on visibility change.
     But when returning to visible, keep existing watch active. */
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // optional: reduce frequency by stopping watch if you want to reduce battery,
      // but per user's request we keep real-time updates; we won't call getCurrentPosition again.
      // stopLocationTracking();
    } else {
      // When becoming visible, ensure tracking is running if user wants location and permission wasn't denied
      if (settings.showLocation && !watchId && permissionState !== 'denied') {
        startLocationTracking();
      }
      // Invalidate map size to force tiles to render if something was clipped while hidden
      setTimeout(() => {
        try { map.invalidateSize(); } catch (e) {}
      }, 120);
    }
  });

  /* -------------------- SUPABASE I/O -------------------- */
  async function loadInitial() {
    const { data, error } = await db
      .from('pulses')
      .select('id, created_at, author_tg_id, category, message, lat, lng, expires_at, status, people_count')
      .eq('status', 'active')
      .gt('expires_at', new Date().toISOString())
      .order('created_at', { ascending: false })
      .limit(300);

    if (error) { console.error(error); return; }
    
    // Get current user ID for identifying own pulses
    let currentUserId = null;
    try {
      const tg = window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe;
      if (tg && tg.user) currentUserId = String(tg.user.id);
    } catch (_) { }

    data.forEach(row => {
      state.pulses.set(row.id, { row, marker: null });
      // Mark user's own pulses
      if (currentUserId && row.author_tg_id === currentUserId) {
        state.myPulses.add(row.id);
      }
    });
    renderPulses();

    // ensure tiles are requested/rendered after loading initial data
    setTimeout(() => { try { map.invalidateSize(); } catch(e){} }, 120);
  }

  function subscribeRealtime() {
    db.channel('realtime:pulses')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'pulses' }, payload => {
        const row = payload.new;
        state.pulses.set(row.id, { row, marker: null });
        
        // Check if this is user's own pulse
        let currentUserId = null;
        try {
          const tg = window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe;
          if (tg && tg.user) currentUserId = String(tg.user.id);
        } catch (_) { }
        
        if (currentUserId && row.author_tg_id === currentUserId) {
          state.myPulses.add(row.id);
        }
        
        renderPulses();
      })
      .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'pulses' }, payload => {
        const row = payload.new;
        state.pulses.set(row.id, { row, marker: null });
        renderPulses();
      })
      .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'pulses' }, payload => {
        const row = payload.old;
        state.pulses.delete(row.id);
        state.myPulses.delete(row.id);
        if (state.selectedPulseId === row.id) {
          state.selectedPulseId = null;
          document.getElementById('deletePulseBtn').style.display = 'none';
        }
        renderPulses();
      })
      .subscribe();
  }

  /* -------------------- CREATE PULSE UI -------------------- */
  const createBtn = document.getElementById('createBtn');
  const createModal = document.getElementById('createModal');
  const createSheet = document.getElementById('createSheet');
  const addressLocationBtn = document.getElementById('addressLocation');
  const customLocationBtn = document.getElementById('customLocation');
  const addressInputContainer = document.getElementById('addressInputContainer');
  const locationMapContainer = document.getElementById('locationMapContainer');
  const msgTextarea = document.getElementById('msg');
  const locationOverlay = document.getElementById('locationOverlay');
  const categoryField = document.getElementById('categoryField');
  const categoryDisplay = document.getElementById('categoryDisplay');
  const categoryFieldLabel = document.getElementById('categoryFieldLabel');
  const categoryModal = document.getElementById('categoryModal');
  const categoryModalTitle = document.getElementById('categoryModalTitle');
  const categoryOptionsEl = document.getElementById('categoryOptions');
  const closeCategoryModalBtn = document.getElementById('closeCategoryModal');
  const peopleField = document.getElementById('peopleField');
  const peopleDisplay = document.getElementById('peopleDisplay');
  const peopleFieldLabel = document.getElementById('peopleFieldLabel');
  const peopleModal = document.getElementById('peopleModal');
  const peopleModalTitle = document.getElementById('peopleModalTitle');
  const peopleOptionsEl = document.getElementById('peopleOptions');
  const closePeopleModalBtn = document.getElementById('closePeopleModal');

  const CREATE_OVERLAY_ALPHA = 0.45;
  const OPTION_OVERLAY_ALPHA = 0.45;

  function setCreateOverlayAlpha(alpha) {
    if (!createModal) return;
    const clamped = Math.max(0, Math.min(CREATE_OVERLAY_ALPHA, alpha));
    createModal.style.background = `rgba(9,12,20,${clamped})`;
  }

  function resetCreateOverlayAlpha() {
    setCreateOverlayAlpha(CREATE_OVERLAY_ALPHA);
  }

  function setOptionOverlayAlpha(modal, alpha) {
    if (!modal) return;
    const clamped = Math.max(0, Math.min(OPTION_OVERLAY_ALPHA, alpha));
    modal.style.background = `rgba(9,12,20,${clamped})`;
  }

  function resetOptionOverlayAlpha(modal) {
    setOptionOverlayAlpha(modal, OPTION_OVERLAY_ALPHA);
  }

  function finishOptionModalClose(modal) {
    if (!modal) return;
    if (modal._optionOpenFrame1) {
      cancelAnimationFrame(modal._optionOpenFrame1);
      modal._optionOpenFrame1 = null;
    }
    if (modal._optionOpenFrame2) {
      cancelAnimationFrame(modal._optionOpenFrame2);
      modal._optionOpenFrame2 = null;
    }
    const sheet = modal.querySelector('.option-sheet');
    if (sheet) {
      if (modal._optionCloseHandler) {
        sheet.removeEventListener('transitionend', modal._optionCloseHandler);
        modal._optionCloseHandler = null;
      }
      sheet.style.transform = 'translateY(100%)';
    }
    modal._optionCloseHandler = null;
    modal.classList.remove('open', 'closing');
    setOptionOverlayAlpha(modal, 0);
  }

  function openCreateModal() {
    if (!createModal) return;
    createModal.classList.remove('closing');
    createModal.classList.add('open');
    setCreateOverlayAlpha(0);
    if (createSheet) {
      createSheet.style.transform = 'translateY(100%)';
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          resetCreateOverlayAlpha();
          createSheet.style.transform = 'translateY(0)';
        });
      });
    } else {
      resetCreateOverlayAlpha();
    }
  }

  function finishCreateModalClose() {
    if (!createModal) return;
    createModal.classList.remove('open', 'closing');
    if (createSheet) {
      createSheet.style.transform = 'translateY(100%)';
    }
    setCreateOverlayAlpha(0);
  }

  function closeCreateModal({ animated = true } = {}) {
    if (!createModal || !createModal.classList.contains('open')) return;
    if (!animated || !createSheet) {
      finishCreateModalClose();
      return;
    }
    createModal.classList.add('closing');
    requestAnimationFrame(() => {
      if (createSheet) {
        createSheet.style.transform = 'translateY(100%)';
      }
      setCreateOverlayAlpha(0);
    });
    const handleTransitionEnd = (event) => {
      if (event.target !== createSheet || event.propertyName !== 'transform') return;
      createSheet.removeEventListener('transitionend', handleTransitionEnd);
      finishCreateModalClose();
    };
    createSheet.addEventListener('transitionend', handleTransitionEnd);
  }

  function resetCreateModalUI() {
    if (locationMapContainer) {
      locationMapContainer.style.display = 'none';
    }
    if (addressInputContainer) {
      addressInputContainer.style.display = 'block';
    }
    closeOptionModal(categoryModal, { animated: false });
    closeOptionModal(peopleModal, { animated: false });
  }

  const categoryDefinitions = [
    { value: 'sport', icon: 'üèÉ', labelKey: 'sport' },
    { value: 'games', icon: 'üéÆ', labelKey: 'games' },
    { value: 'art', icon: 'üé®', labelKey: 'art' },
    { value: 'social', icon: 'üë•', labelKey: 'social' },
    { value: 'creative', icon: 'üí°', labelKey: 'creative' },
    { value: 'chill', icon: 'üòå', labelKey: 'chill' },
    { value: 'active', icon: '‚ö°', labelKey: 'active' },
    { value: 'dating', icon: 'üíï', labelKey: 'dating' },
    { value: 'education', icon: 'üìö', labelKey: 'education' },
    { value: 'animal', icon: 'üêï', labelKey: 'animal' },
    { value: 'help', icon: 'ü§ù', labelKey: 'help' }
  ];

  const peopleValues = [1, 2, 3, 4, 5];

  let selectedCategory = 'sport';
  let selectedPeopleCount = 5;

  function openOptionModal(modal) {
    if (!modal) return;
    const sheet = modal.querySelector('.option-sheet');

    if (sheet && modal._optionCloseHandler) {
      sheet.removeEventListener('transitionend', modal._optionCloseHandler);
      modal._optionCloseHandler = null;
    }

    if (modal._optionOpenFrame1) {
      cancelAnimationFrame(modal._optionOpenFrame1);
      modal._optionOpenFrame1 = null;
    }
    if (modal._optionOpenFrame2) {
      cancelAnimationFrame(modal._optionOpenFrame2);
      modal._optionOpenFrame2 = null;
    }

    modal.classList.remove('closing');
    modal.classList.add('open');
    setOptionOverlayAlpha(modal, 0);

    if (!sheet) {
      resetOptionOverlayAlpha(modal);
      return;
    }

    sheet.style.transform = 'translateY(100%)';

    modal._optionOpenFrame1 = requestAnimationFrame(() => {
      modal._optionOpenFrame2 = requestAnimationFrame(() => {
        modal._optionOpenFrame1 = null;
        modal._optionOpenFrame2 = null;
        resetOptionOverlayAlpha(modal);
        sheet.style.transform = 'translateY(0)';
      });
    });
  }

  function closeOptionModal(modal, { animated = true } = {}) {
    if (!modal || !modal.classList.contains('open')) return;
    const sheet = modal.querySelector('.option-sheet');

    if (modal._optionOpenFrame1) {
      cancelAnimationFrame(modal._optionOpenFrame1);
      modal._optionOpenFrame1 = null;
    }
    if (modal._optionOpenFrame2) {
      cancelAnimationFrame(modal._optionOpenFrame2);
      modal._optionOpenFrame2 = null;
    }

    if (!animated || !sheet) {
      finishOptionModalClose(modal);
      return;
    }

    if (modal._optionCloseHandler) {
      sheet.removeEventListener('transitionend', modal._optionCloseHandler);
      modal._optionCloseHandler = null;
    }

    modal.classList.add('closing');

    const handleTransitionEnd = (event) => {
      if (event.target !== sheet || event.propertyName !== 'transform') return;
      sheet.removeEventListener('transitionend', handleTransitionEnd);
      modal._optionCloseHandler = null;
      finishOptionModalClose(modal);
    };

    modal._optionCloseHandler = handleTransitionEnd;
    sheet.addEventListener('transitionend', handleTransitionEnd);

    requestAnimationFrame(() => {
      sheet.style.transform = 'translateY(100%)';
      setOptionOverlayAlpha(modal, 0);
    });
  }

  function updateMessagePlaceholder() {
    if (!msgTextarea) return;
    const hints = categoryHints[currentLanguage] || {};
    msgTextarea.placeholder = hints[selectedCategory] || translations[currentLanguage].writeMessage;
  }

  function updateCategoryDisplay() {
    if (!categoryDisplay) return;
    const t = translations[currentLanguage];
    const def = categoryDefinitions.find(item => item.value === selectedCategory) || categoryDefinitions[0];
    if (!def) return;
    categoryDisplay.textContent = `${def.icon} ${t[def.labelKey]}`;
    if (categoryOptionsEl) {
      categoryOptionsEl.querySelectorAll('.option-card').forEach(optionEl => {
        optionEl.classList.toggle('active', optionEl.dataset.value === selectedCategory);
      });
    }
    updateMessagePlaceholder();
  }

  function updatePeopleDisplay() {
    if (!peopleDisplay) return;
    peopleDisplay.textContent = formatPeopleCount(selectedPeopleCount, currentLanguage);
    if (peopleOptionsEl) {
      peopleOptionsEl.querySelectorAll('.option-card').forEach(optionEl => {
        const value = Number(optionEl.dataset.value);
        optionEl.classList.toggle('active', value === selectedPeopleCount);
      });
    }
  }

  function updateRadiusLabels() {
    const slider = document.getElementById('radiusSlider');
    const t = translations[currentLanguage];
    if (!slider || !t) return;

    const unit = t.distanceUnit || '';
    const sliderEnds = document.querySelectorAll('.slider-end');
    if (sliderEnds.length >= 2) {
      const minLabel = unit ? `${slider.min} ${unit}` : slider.min;
      const maxLabel = unit ? `${slider.max} ${unit}` : slider.max;
      sliderEnds[0].textContent = minLabel;
      sliderEnds[1].textContent = maxLabel;
    }

    const radiusValueEl = document.getElementById('radiusValue');
    if (radiusValueEl) {
      const displayValue = Number.isFinite(Number(settings.searchRadius)) ? Number(settings.searchRadius) : settings.searchRadius;
      radiusValueEl.textContent = unit ? `${displayValue} ${unit}` : String(displayValue);
    }
  }

  function renderCategoryOptions() {
    if (!categoryOptionsEl) return;
    const t = translations[currentLanguage];
    categoryOptionsEl.innerHTML = '';
    categoryDefinitions.forEach(def => {
      const option = document.createElement('div');
      option.className = 'option-card' + (def.value === selectedCategory ? ' active' : '');
      option.dataset.value = def.value;
      option.innerHTML = `
        <div class="option-info">
          <div class="option-icon">${def.icon}</div>
          <div class="option-text">
            <div class="option-title">${t[def.labelKey]}</div>
          </div>
        </div>
        <div class="option-check">‚úì</div>
      `;
      categoryOptionsEl.appendChild(option);
    });
  }

  function renderPeopleOptions() {
    if (!peopleOptionsEl) return;
    peopleOptionsEl.innerHTML = '';
    peopleValues.forEach(count => {
      const option = document.createElement('div');
      option.className = 'option-card' + (count === selectedPeopleCount ? ' active' : '');
      option.dataset.value = String(count);
      option.innerHTML = `
        <div class="option-info no-icon">
          <div class="option-text">
            <div class="option-title">${formatPeopleCount(count, currentLanguage)}</div>
          </div>
        </div>
        <div class="option-check">‚úì</div>
      `;
      peopleOptionsEl.appendChild(option);
    });
  }

  if (categoryField) {
    categoryField.addEventListener('click', () => {
      if (categoryOptionsEl && !categoryOptionsEl.childElementCount) {
        renderCategoryOptions();
      }
      openOptionModal(categoryModal);
    });
  }

  if (closeCategoryModalBtn) {
    closeCategoryModalBtn.addEventListener('click', () => closeOptionModal(categoryModal));
  }

  if (categoryModal) {
    categoryModal.addEventListener('click', (event) => {
      if (event.target === categoryModal) {
        closeOptionModal(categoryModal);
      }
    });
  }

  if (categoryOptionsEl) {
    categoryOptionsEl.addEventListener('click', (event) => {
      const optionEl = event.target.closest('.option-card');
      if (!optionEl) return;
      const value = optionEl.dataset.value;
      if (!value) return;
      selectedCategory = value;
      updateCategoryDisplay();
      closeOptionModal(categoryModal);
    });
  }

  if (peopleField) {
    peopleField.addEventListener('click', () => {
      if (peopleOptionsEl && !peopleOptionsEl.childElementCount) {
        renderPeopleOptions();
      }
      openOptionModal(peopleModal);
    });
  }

  if (closePeopleModalBtn) {
    closePeopleModalBtn.addEventListener('click', () => closeOptionModal(peopleModal));
  }

  if (peopleModal) {
    peopleModal.addEventListener('click', (event) => {
      if (event.target === peopleModal) {
        closeOptionModal(peopleModal);
      }
    });
  }

  if (peopleOptionsEl) {
    peopleOptionsEl.addEventListener('click', (event) => {
      const optionEl = event.target.closest('.option-card');
      if (!optionEl) return;
      const value = Number(optionEl.dataset.value);
      if (!value) return;
      selectedPeopleCount = value;
      updatePeopleDisplay();
      closeOptionModal(peopleModal);
    });
  }

  if (createModal) {
    createModal.addEventListener('click', (event) => {
      if (event.target === createModal) {
        closeCreateModal();
        resetCreateModalUI();
      }
    });
  }

  document.getElementById('cancelCreate').onclick = () => {
    closeCreateModal();
    resetCreateModalUI();
  };

  createBtn.onclick = () => {
    if (categoryOptionsEl && !categoryOptionsEl.childElementCount) {
      renderCategoryOptions();
    }
    if (peopleOptionsEl && !peopleOptionsEl.childElementCount) {
      renderPeopleOptions();
    }
    updateCategoryDisplay();
    updatePeopleDisplay();
    openCreateModal();
  };

  addressLocationBtn.onclick = () => {
    addressLocationBtn.classList.add('active');
    customLocationBtn.classList.remove('active');
    locationMapContainer.style.display = 'none';
    addressInputContainer.style.display = 'block';
    state.selectedLocation = null;
    updateLocationDistanceElements();
  };

  customLocationBtn.onclick = () => {
    customLocationBtn.classList.add('active');
    addressLocationBtn.classList.remove('active');
    locationMapContainer.style.display = 'block';
    addressInputContainer.style.display = 'none';

    locationOverlay.classList.add('active');

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Telegram WebView - –Ω—É–∂–Ω–∞ –±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
    const isTelegram = window.Telegram && window.Telegram.WebApp;
    const initDelay = isTelegram ? 300 : 50;

    // –ñ–¥–µ–º –ø–æ–∫–∞ overlay —Å—Ç–∞–Ω–µ—Ç –≤–∏–¥–∏–º—ã–º –ø–µ—Ä–µ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π –∫–∞—Ä—Ç—ã
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º requestAnimationFrame –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ –≤ Telegram
    const initMap = () => {
      if (!locationSelectMap) {
        initLocationSelectionMap();
      } else {
        const target = state.selectedLocation ? [state.selectedLocation[0], state.selectedLocation[1]] : [center[0], center[1]];
        const clampedTarget = clampToRadius(target);
        locationSelectMap.setView(center, 15);
        if (selectedLocationMarker) {
          selectedLocationMarker.setLatLng(clampedTarget);
        }
        selectedLocation = [clampedTarget.lat, clampedTarget.lng];
        updateLocationSelectionShapes();
        updateLocationDistanceElements();
        
        // –î–ª—è Telegram –¥–µ–ª–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ø—ã—Ç–æ–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        const invalidateAttempts = isTelegram ? 3 : 1;
        for (let i = 0; i < invalidateAttempts; i++) {
          setTimeout(() => {
            requestAnimationFrame(() => {
              try { 
                locationSelectMap.invalidateSize(true); // reset size
                // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–ª—ã
                locationSelectMap.eachLayer((layer) => {
                  if (layer instanceof L.TileLayer) {
                    layer.redraw();
                  }
                });
                // –ù–µ–±–æ–ª—å—à–æ–π –ø–∞–Ω –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏ —Ç–∞–π–ª–æ–≤
                if (i === 0) {
                  locationSelectMap.panBy([0.5, 0], { animate: false });
                  setTimeout(() => {
                    locationSelectMap.panBy([-0.5, 0], { animate: false });
                  }, 50);
                }
              } catch(e) {
                console.warn('Location map update attempt', i + 1, 'failed:', e);
              }
            });
          }, (i + 1) * 150);
        }
      }
    };
    
    if (isTelegram) {
      // –î–ª—è Telegram –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —É—Ä–æ–≤–Ω–µ–π –∑–∞–¥–µ—Ä–∂–µ–∫
      setTimeout(() => {
        requestAnimationFrame(() => {
          setTimeout(() => {
            requestAnimationFrame(initMap);
          }, 50);
        });
      }, initDelay);
    } else {
      setTimeout(initMap, initDelay);
    }
  };

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –æ–≤–µ—Ä–ª–µ—è –≤—ã–±–æ—Ä–∞ –ª–æ–∫–∞—Ü–∏–∏
  document.getElementById('cancelLocationSelect').onclick = () => {
    locationOverlay.classList.remove('active');
  };

  // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∫–æ–≥–¥–∞ overlay —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤–∏–¥–∏–º—ã–º
  // –≠—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ –≤–∞–∂–Ω–æ –¥–ª—è Telegram WebView
  const locationOverlayEl = document.getElementById('locationOverlay');
  if (locationOverlayEl) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º MutationObserver –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–ª–∞—Å—Å–∞ active
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const isActive = locationOverlayEl.classList.contains('active');
          if (isActive && locationSelectMap) {
            // –ö–æ–≥–¥–∞ overlay —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∞–∫—Ç–∏–≤–Ω—ã–º, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–∞—Ä—Ç—É
            const isTelegram = window.Telegram && window.Telegram.WebApp;
            const delay = isTelegram ? 400 : 200;
            
            setTimeout(() => {
              requestAnimationFrame(() => {
                try {
                  locationSelectMap.invalidateSize(true); // true = reset size
                  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≤—Å–µ —Ç–∞–π–ª—ã
                  locationSelectMap.eachLayer((layer) => {
                    if (layer instanceof L.TileLayer) {
                      layer.redraw();
                    }
                  });
                  // –ù–µ–±–æ–ª—å—à–æ–π –ø–∞–Ω –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏
                  locationSelectMap.panBy([1, 0], { animate: false });
                  setTimeout(() => {
                    requestAnimationFrame(() => {
                      locationSelectMap.panBy([-1, 0], { animate: false });
                    });
                  }, 100);
                } catch (e) {
                  console.warn('Location map refresh failed:', e);
                }
              });
            }, delay);
          }
        }
      });
    });
    
    observer.observe(locationOverlayEl, {
      attributes: true,
      attributeFilter: ['class']
    });
  }

  document.getElementById('confirmLocationSelect').onclick = () => {
    if (selectedLocation) {
      state.selectedLocation = selectedLocation;
      locationOverlay.classList.remove('active');
      document.getElementById('addressInput').value = '';
    }
  };

  document.getElementById('saveCreate').onclick = async () => {
    const cat = selectedCategory;
    const msg = document.getElementById('msg').value.trim().slice(0, 180);
    const peopleCount = Number(selectedPeopleCount) || 5;
    const addressInput = document.getElementById('addressInput').value.trim();
    const t = translations[currentLanguage];

    let pulseLat, pulseLng;

    if (state.selectedLocation) {
      [pulseLat, pulseLng] = state.selectedLocation;
    } else if (addressInput && t && addressInput !== t.enterAddress) {
      pulseLat = state.me.lat ?? center[0];
      pulseLng = state.me.lng ?? center[1];
    } else {
      pulseLat = state.me.lat ?? center[0];
      pulseLng = state.me.lng ?? center[1];
    }

    const expires = new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString();

    let tgId = null;
    try {
      const tg = window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe;
      if (tg && tg.user) tgId = String(tg.user.id);
    } catch (_) { }

    const row = {
      category: cat,
      message: msg || 'ping',
      lat: pulseLat,
      lng: pulseLng,
      expires_at: expires,
      status: 'active',
      author_tg_id: tgId,
      people_count: peopleCount
    };

    const { data, error } = await db.from('pulses').insert(row).select().single();
    if (error) {
      const message = (error && error.message) || (t ? t.errorUnknown : 'unknown');
      const prefix = t ? t.createError : 'Error creating pulse';
      alert(`${prefix}: ${message}`);
      return;
    }

    state.pulses.set(data.id, { row: data, marker: null });
    
    // Mark as user's own pulse
    if (tgId) {
      state.myPulses.add(data.id);
    }
    
    renderPulses();

    const focusNewPulse = () => {
      if (!map) return;
      const targetLatLng = [pulseLat, pulseLng];
      const currentZoom = typeof map.getZoom === 'function' ? map.getZoom() : 15;
      const targetZoom = Number.isFinite(currentZoom) ? Math.max(currentZoom, 15) : 15;

      const revealPulse = () => {
        const entry = state.pulses.get(data.id);
        if (entry && entry.marker && typeof entry.marker.openTooltip === 'function') {
          entry.marker.openTooltip();
        }
        if (state.myPulses && state.myPulses.has(data.id)) {
          state.selectedPulseId = data.id;
          const deleteBtn = document.getElementById('deletePulseBtn');
          if (deleteBtn) {
            deleteBtn.style.display = 'grid';
          }
        }
      };

      if (typeof map.flyTo === 'function') {
        map.once('moveend', revealPulse);
        map.flyTo(targetLatLng, targetZoom, {
          animate: true,
          duration: 0.9,
          easeLinearity: 0.25
        });
      } else if (typeof map.setView === 'function') {
        map.setView(targetLatLng, targetZoom, { animate: true, duration: 0.9 });
        revealPulse();
      }
    };

    setTimeout(focusNewPulse, 350);
    closeCreateModal();
    resetCreateModalUI();
    document.getElementById('msg').value = '';
    document.getElementById('addressInput').value = '';
  };

  /* -------------------- SETTINGS FUNCTIONALITY -------------------- */
  const settingsModal = document.getElementById('settingsModal');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsSheet = document.getElementById('settingsSheet');
  const settingsSheetBody = document.getElementById('settingsSheetBody');
  const settingsHeader = document.getElementById('settingsHeader');
  const settingsClose = document.getElementById('settingsClose');

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
  function initSettings() {
    const savedSettings = localStorage.getItem('radius5_settings');
    if (savedSettings) {
      Object.assign(settings, JSON.parse(savedSettings));
    }

    const savedLanguage = localStorage.getItem('radius5_language');
    if (savedLanguage) {
      currentLanguage = savedLanguage;
    } else if (settings.language) {
      currentLanguage = settings.language;
    }

    settings.language = currentLanguage;

    applySettings();
    updateSettingsUI();
    applyLanguage(currentLanguage);
  }

  function applySettings() {
    applyTheme(settings.darkMode);

    radiusMeters = settings.searchRadius * 1000;
    mask.setRadius(radiusMeters);
    ring.setRadius(radiusMeters);
    updateLocationSelectionShapes();
    if (selectedLocationMarker) {
      const clamped = clampToRadius(selectedLocationMarker.getLatLng());
      selectedLocationMarker.setLatLng(clamped);
      selectedLocation = [clamped.lat, clamped.lng];
    }

    if (settings.showLocation) {
      meMarker.addTo(map);
      // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ª–æ–∫–∞—Ü–∏–∏ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
      startLocationTracking();
    } else {
      meMarker.remove();
      // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –µ—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω–æ
      stopLocationTracking();
    }

    renderPulses();
  }

  function updateSettingsUI() {
    document.getElementById('darkModeToggle').classList.toggle('active', settings.darkMode);
    document.getElementById('showLocationToggle').classList.toggle('active', settings.showLocation);
    document.getElementById('showDistanceToggle').classList.toggle('active', settings.showDistance);
    document.getElementById('notificationsToggle').classList.toggle('active', settings.notifications);
    document.getElementById('autoRefreshToggle').classList.toggle('active', settings.autoRefresh);
    document.getElementById('vibrationToggle').classList.toggle('active', settings.vibration);
    document.getElementById('pulseVisibilityToggle').classList.toggle('active', settings.pulseVisibility);
    
    const radiusSliderEl = document.getElementById('radiusSlider');
    if (radiusSliderEl) {
      radiusSliderEl.value = settings.searchRadius;
    }
    updateRadiusLabels();
    // keep lastSliderValue in sync when UI updates
    lastSliderValue = settings.searchRadius;
    
    // Update visibility options
    document.getElementById('visibilityOptions').classList.toggle('active', settings.pulseVisibility);
    document.querySelectorAll('[data-visibility]').forEach(toggle => {
      toggle.classList.toggle('active', toggle.dataset.visibility === settings.visibilityMode);
    });
    document.querySelectorAll('.language-option').forEach(option => {
      option.classList.toggle('active', option.dataset.lang === settings.language);
    });
  }

  const SWIPE_CLOSE_THRESHOLD = 80;
  const BASE_OVERLAY_ALPHA = 0.45;
  const MIN_OVERLAY_ALPHA = 0.1;

  let lastSliderValue = settings.searchRadius;
  let isDraggingSettingsSheet = false;
  let dragStartY = 0;
  let currentSheetOffset = 0;

  function persistSettings() {
    localStorage.setItem('radius5_settings', JSON.stringify(settings));
    if (settings.language) {
      localStorage.setItem('radius5_language', settings.language);
    }
  }

  function hapticPulse(duration = 20, force = false) {
    if ((force || settings.vibration) && navigator.vibrate) {
      navigator.vibrate(duration);
    }
  }

  function setOverlayAlpha(alpha) {
    if (!settingsModal) return;
    const clamped = Math.max(0, Math.min(BASE_OVERLAY_ALPHA, alpha));
    settingsModal.style.background = `rgba(9,12,20,${clamped})`;
  }

  function resetOverlayAlpha() {
    setOverlayAlpha(BASE_OVERLAY_ALPHA);
  }

  function openSettingsModal() {
    if (!settingsModal) return;
    updateSettingsUI();
    if (settingsSheetBody) {
      settingsSheetBody.scrollTop = 0;
    }
    setOverlayAlpha(0);
    settingsModal.classList.remove('closing');
    settingsModal.classList.add('open');
    if (settingsSheet) {
      settingsSheet.classList.remove('spring', 'dragging');
      settingsSheet.style.transform = 'translateY(100%)';
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          setOverlayAlpha(BASE_OVERLAY_ALPHA);
          settingsSheet.style.transform = 'translateY(0)';
        });
      });
    } else {
      resetOverlayAlpha();
    }
  }

  function finishSettingsModalClose() {
    if (!settingsModal) return;
    settingsModal.classList.remove('open', 'closing');
    if (settingsSheet) {
      settingsSheet.classList.remove('dragging', 'spring');
      settingsSheet.style.transform = 'translateY(100%)';
    }
    setOverlayAlpha(0);
  }

  function closeSettingsModal({ animated = true } = {}) {
    if (!settingsModal || !settingsModal.classList.contains('open')) return;
    if (!animated || !settingsSheet) {
      finishSettingsModalClose();
      return;
    }
    settingsModal.classList.add('closing');
    settingsSheet.classList.remove('dragging', 'spring');
    requestAnimationFrame(() => {
      settingsSheet.style.transform = 'translateY(100%)';
      setOverlayAlpha(0);
    });
    const handleTransitionEnd = (event) => {
      if (event.target !== settingsSheet || event.propertyName !== 'transform') return;
      settingsSheet.removeEventListener('transitionend', handleTransitionEnd);
      finishSettingsModalClose();
    };
    settingsSheet.addEventListener('transitionend', handleTransitionEnd);
  }

  function snapSettingsSheetBack() {
    if (!settingsSheet) return;
    settingsSheet.classList.remove('dragging');
    settingsSheet.classList.add('spring');
    settingsSheet.style.transform = 'translateY(0)';
    resetOverlayAlpha();
    settingsSheet.addEventListener('transitionend', () => {
      settingsSheet.classList.remove('spring');
    }, { once: true });
  }

  function beginSettingsSheetDrag(event) {
    if (!settingsSheet || !settingsHeader) return;
    if (event.pointerType === 'mouse' && event.button !== 0) return;
    if (settingsSheetBody && settingsSheetBody.scrollTop > 0) return;
    isDraggingSettingsSheet = true;
    dragStartY = event.clientY;
    currentSheetOffset = 0;
    settingsSheet.classList.add('dragging');
    settingsHeader.setPointerCapture?.(event.pointerId);
  }

  function moveSettingsSheetDrag(event) {
    if (!isDraggingSettingsSheet || !settingsSheet) return;
    const delta = event.clientY - dragStartY;
    if (delta <= 0) {
      currentSheetOffset = 0;
      settingsSheet.style.transform = 'translateY(0)';
      resetOverlayAlpha();
      return;
    }
    currentSheetOffset = delta;
    settingsSheet.style.transform = `translateY(${delta}px)`;
    const progress = Math.min(delta / 320, 1);
    const overlayAlpha = BASE_OVERLAY_ALPHA - progress * (BASE_OVERLAY_ALPHA - MIN_OVERLAY_ALPHA);
    setOverlayAlpha(overlayAlpha);
    event.preventDefault();
  }

  function endSettingsSheetDrag(event) {
    if (!isDraggingSettingsSheet) return;
    settingsHeader?.releasePointerCapture?.(event.pointerId);
    isDraggingSettingsSheet = false;
    const shouldClose = currentSheetOffset > SWIPE_CLOSE_THRESHOLD;
    currentSheetOffset = 0;
    if (shouldClose) {
      closeSettingsModal({ animated: true });
    } else {
      snapSettingsSheetBack();
    }
  }

  if (settingsHeader) {
    settingsHeader.style.touchAction = 'none';
    settingsHeader.addEventListener('pointerdown', beginSettingsSheetDrag);
    settingsHeader.addEventListener('pointermove', moveSettingsSheetDrag);
    settingsHeader.addEventListener('pointerup', endSettingsSheetDrag);
    settingsHeader.addEventListener('pointercancel', endSettingsSheetDrag);
  }

  if (settingsClose) {
    settingsClose.addEventListener('click', () => {
      closeSettingsModal({ animated: true });
      hapticPulse(20, true);
    });
  }

  if (settingsModal) {
    settingsModal.addEventListener('click', (event) => {
      if (event.target === settingsModal) {
        closeSettingsModal({ animated: true });
      }
    });
  }

  const registerToggle = (id, key, { apply = false, onChange } = {}) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('click', () => {
      const newValue = !settings[key];
      settings[key] = newValue;
      if (typeof onChange === 'function') {
        onChange(newValue);
      }
      updateSettingsUI();
      if (apply) {
        applySettings();
      }
      persistSettings();
      if (key === 'vibration') {
        hapticPulse(20, true);
      } else {
        hapticPulse(20);
      }
    });
  };

  registerToggle('darkModeToggle', 'darkMode', { apply: true });
  registerToggle('showLocationToggle', 'showLocation', {
    apply: true,
    onChange: (isActive) => {
      if (!isActive) {
        clearPulseDistanceOverlays();
      }
    }
  });
  registerToggle('notificationsToggle', 'notifications');
  registerToggle('showDistanceToggle', 'showDistance', {
    onChange: (isActive) => {
      if (isActive) {
        renderPulses();
        refreshPulseDistanceOverlaysFromState();
      } else {
        clearPulseDistanceOverlays();
      }
    }
  });
  registerToggle('autoRefreshToggle', 'autoRefresh');
  registerToggle('vibrationToggle', 'vibration');
  registerToggle('pulseVisibilityToggle', 'pulseVisibility', {
    onChange: (isActive) => {
      const options = document.getElementById('visibilityOptions');
      if (options) {
        options.classList.toggle('active', isActive);
      }
    }
  });

  const visibilityToggles = document.querySelectorAll('[data-visibility]');
  visibilityToggles.forEach(toggle => {
    toggle.addEventListener('click', function() {
      visibilityToggles.forEach(t => t.classList.remove('active'));
      this.classList.add('active');
      settings.visibilityMode = this.dataset.visibility;
      persistSettings();
      hapticPulse(16);
    });
  });

  const languageOptions = document.querySelectorAll('.language-option');
  languageOptions.forEach(option => {
    option.addEventListener('click', function() {
      const lang = this.dataset.lang;
      if (!lang || lang === settings.language) return;
      languageOptions.forEach(opt => opt.classList.remove('active'));
      this.classList.add('active');
      settings.language = lang;
      persistSettings();
      applyLanguage(lang);
      hapticPulse(18);
    });
  });

  const radiusSliderEl = document.getElementById('radiusSlider');
  if (radiusSliderEl) {
    radiusSliderEl.addEventListener('input', function() {
      const value = parseFloat(this.value);
      if (Number.isNaN(value)) return;
      settings.searchRadius = value;
      updateRadiusLabels();
      applySettings();
      persistSettings();
      if (navigator.vibrate && settings.vibration) {
        const isNowFive = Math.round(settings.searchRadius) === 5;
        const wasFive = Math.round(lastSliderValue) === 5;
        if (isNowFive && !wasFive) {
          navigator.vibrate(30);
        }
      }
      lastSliderValue = settings.searchRadius;
    });
  }

  if (settingsBtn) {
    settingsBtn.onclick = () => {
      openSettingsModal();
    };
  }

  const profileBtn = document.getElementById('profileBtn');
  if (profileBtn) {
    profileBtn.onclick = () => {
      alert('–ü—Ä–æ—Ñ–∏–ª—å - —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ');
    };
  }

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      if (settingsModal && settingsModal.classList.contains('open')) {
        closeSettingsModal({ animated: true });
        return;
      }
      if (createModal && createModal.classList.contains('open')) {
        closeCreateModal();
        resetCreateModalUI();
      }
    }
  });

  /* -------------------- HELPERS -------------------- */
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
  }

  /* -------------------- INIT -------------------- */
  loadInitial();
  subscribeRealtime();
  initSettings();

  // Add click handler for delete button
  document.getElementById('deletePulseBtn').addEventListener('click', deleteSelectedPulse);

  // Add click handler for geolocation button
  document.getElementById('geolocationBtn').addEventListener('click', () => {
    if (settings.showLocation && !watchId) {
      startLocationTracking();
    }

    const hasValidLocation = state.hasLocation && state.me && Number.isFinite(state.me.lat) && Number.isFinite(state.me.lng);

    if (hasValidLocation) {
      map.setView([state.me.lat, state.me.lng], 15, {
        animate: true,
        duration: 0.5
      });

      if (settings.vibration && navigator.vibrate) {
        navigator.vibrate(30);
      }
    } else if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(pos => {
        const { latitude, longitude } = pos.coords;
        map.setView([latitude, longitude], 15, {
          animate: true,
          duration: 0.5
        });
        // –°–±—Ä–æ—Å–∏—Ç—å —Ñ–ª–∞–≥ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏
        hasInitialCentered = false;
        moveCircle(latitude, longitude);

        if (settings.vibration && navigator.vibrate) {
          navigator.vibrate(30);
        }
      }, error => {
        console.log('Geolocation error:', error);
        const t = translations[currentLanguage];
        const message = (error && error.message) || t.errorGeneric || t.errorUnknown;
        alert(`${t.returnToLocation} - ${message}`);
      }, { enableHighAccuracy: true, timeout: 15000 });
    } else {
      const t = translations[currentLanguage];
      alert(`${t.returnToLocation} - ${t.errorUnknown}`);
    }
  });

  // Hide delete button when clicking on map (not on markers)
  map.on('click', e => {
    // Check if click was on a marker (if so, don't hide delete button)
    const point = map.latLngToContainerPoint(e.latlng);
    const isMarkerClick = Object.values(pulsesLayer._layers).some(layer => {
      if (layer instanceof L.Marker) {
        const markerPoint = map.latLngToContainerPoint(layer.getLatLng());
        const distance = Math.sqrt(
          Math.pow(point.x - markerPoint.x, 2) + 
          Math.pow(point.y - markerPoint.y, 2)
        );
        return distance < 30; // If click within 30px of marker center
      }
      return false;
    });
    
    if (!isMarkerClick) {
      document.getElementById('deletePulseBtn').style.display = 'none';
      state.selectedPulseId = null;
    }
  });

  setInterval(() => {
    if (settings.autoRefresh) {
      renderPulses();
    }
  }, 60000);

  function clearLocationDistanceLines() {
    if (!locationDistanceLines || locationDistanceLines.length === 0) return;
    locationDistanceLines.forEach(line => {
      try { line.remove(); } catch (_) {}
    });
    locationDistanceLines = [];
  }

}
</script>
</body>
</html>